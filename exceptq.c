/*********************************************************************
  exceptq.c
  $Id: exceptq.c,v 1.7 2008/05/24 23:30:53 Steven Exp $

 DLL containing an exception handler for gathering trap information
 This DLL dumps all important debugging Data and is accessible
 from both 16 bit and 32 bits programs

 DLL is 32-bit code, but can handle exceptions from 16-bit code
 Some functions use statics where autos could work to minimize stack usage
 Probably not useful these days

 Symbolic data can be extracted from
   Embedded PM32 debug data (VAC HLL format)
   DBG files (VAC HLL format)
   Embedded CodeView debug data
   DBG files (CodeView format)
   .sym files (generated by mapsym)

 vim: set tabs=4

  fixme to replace dis386
  fixme to have xlseek with error checking
  fixme to have xread with error checking
  fixme to use DosAllocMem rather than calloc/malloc - avoids death if heap corrupted
  fixme to merge CodeView debug reader into HLL debug reader
*/

/**********************************************************************/
/* Version: 2.2             |   Marc Fiammante (FIAMMANT at LGEPROFS) */
/*                          |   La Gaude FRANCE                       */
/*                          |   Internet: fiammante@vnet.ibm.com      */
/* Version: 5.0             |   John Currier  (JCURRIER at CLTVM1)    */
/*                          |   Internet: currier@vnet.ibm.com        */
/* Version: 6.0             |   Kim Rasmussen (krasmus@ibm.net)       */
/*                          |   Denmark                               */
/* Version: 6.1             |   Anthony Cruise (CRUISE at YKTVMH)     */
/*                          |   Watson Research                       */
/* Version: 6.2             |   John Currier  (JCURRIER at CLTVM1)    */
/*                          |   Internet: currier@vnet.ibm.com        */
/* Version: 6.3             |   Kim Rasmussen (kr@belle.dk)           */
/*                          |   Denmark                               */
/*                          |   Marc Fiammante (FIAMMANT at LGEPROFS) */
/*                          |   La Gaude FRANCE                       */
/*                          |   Internet: fiammante@vnet.ibm.com      */
/* Version: 6.4             |   Kim Rasmussen (kr@belle.dk)           */
/*                          |   Denmark - http://www.belle.dk/kr/     */
/* Version: 6.5             |   Steven Levine (steve53@earthlink.net) */
/* Version: 6.6             |   Steven Levine (steve53@earthlink.net) */
/*                                                                    */
/**********************************************************************/
/*                                                                    */
/**********************************************************************/
/* History:                                                           */
/* --------                                                           */
/*                                                                    */
/* created: Marc Fiammante December 1992                              */
/* changed: John Currier   August   1994                              */
/* changed: Kim Rasmussen, May 1995                                   */
/*    Dump of auto-variables added (32-bit only)                      */
/* changed: Anthony Cruise, May 1995                                  */
/*    Do not dump duplicate lines  (32-bit only)                      */
/* fixed  : Marc Fiammante thanks to Bill Siddall                     */
/*    Dump of auto-variables wrong values                             */
/* fixed  : John Currier fix stack thunk on non fatal exceptions      */
/*         fixed DosQueryMem Size test on return                      */
/* fixed  : Marc Fiammante find stack bottom from top to bottom       */
/*         avoid traps on disassemble.                                */
/* changed: Support for VisualAge C added (new debug format)          */
/* changed: Steven Levine Jul 2000                                    */
/*          Read32PmDebug: avoid autovar_def overflow trap            */
/*          Read32PmDebug: avoid locating wrong function vars         */
/*                         use symproc.length to bound lookup         */
/* changed: Steven Levine Aug 2005                                    */
/*          DosQueryModFromEIP Rework decl to match toolkit           */
/* changed: Steven Levine   Aug 2005                                  */
/*          Reformat with indent.exe                                  */
/*          Correct source filename decode                            */
/* changed: Steven Levine   Jan 2006                                  */
/*          Enhance 32-bit detect                                     */
/* changed: Steven Levine   Jul 2007                                  */
/*          More 32-bit rework.  More 16-bit support                  */
/* changed: Steven Levine   Aug 2007                                  */
/*          Generate hex trap file name                               */
/*          Show PID in hex/dec                                       */
/*          Show exceptq build date                                   */
/* changed: Steven Levine   Oct 2007                                  */
/*          List labels on stack                                      */
/*          Show more in hex/dec                                      */
/* changed: Steven Levine   Dec 2007                                  */
/*          Show exceptq version                                      */
/* changed: Steven Levine   Feb 2008                                  */
/*          Use bsedos.h                                              */
/*          Use more omf.h                                            */
/* changed: Steven Levine   Apr 2008                                  */
/*          Version 6.6                                               */
/*          Show stack as dwords or words                             */
/* changed: Steven Levine   May 2008                                  */
/*          Version 6.7                                               */
/*          Support oversized (>64KiB) symbol files                   */
/*          Support stripped LX executables                           */
/*                                                                    */
/**********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include <fcntl.h>
#include <sys\stat.h>
#include <share.h>
#include <io.h>

#define INCL_BASE
#define INCL_DOSEXCEPTIONS
#define INCL_DOSMODULEMGR		/* DosQueryMod... */
#define INCL_DOSSEMAPHORES
#define INCL_DOSPROFILE			// _QSPTRREC

#include <os2.h>

#include <exe.h>
#include <newexe.h>

// fixme to not need
#define  FOR_EXEHDR  1		/* avoid define conflicts between newexe.h and exe386.h */
#include <exe386.h>

#define EXCEPTQ_VERSION	"6.7"		// 23 May 08 SHL
#define WANT_CODEVIEW			// 10 Oct 07 SHL fixme to use
#define WANT_BC09			// 22 May 08 SHL fixme to use
// #define DEBUG			// 11 Oct 07 SHL fixme to use

#include "sym.h"
#include "omf.h"

#ifndef DWORD
#define DWORD ULONG
#endif

#ifndef WORD
#define WORD  USHORT
#endif

#define FLATCS ((USHORT)0x5B)
#define FLATDS ((USHORT)0x53)

#pragma stack16(512)

static FILE *hTrap;

// DosDebug interface

typedef struct
{
    ULONG Pid;			/* Debuggee Process ID */
    ULONG Tid;			/* Debuggee Thread ID */
    LONG Cmd;			/* Command or Notification */
    LONG Value;			/* Generic Data Value */
    ULONG Addr;			/* Debuggee Address */
    ULONG Buffer;		/* Debugger Buffer Address */
    ULONG Len;			/* Length of Range */
    ULONG Index;		/* Generic Identifier Index */
    ULONG MTE;			/* Module Handle */
    ULONG EAX;			/* Register Set */
    ULONG ECX;
    ULONG EDX;
    ULONG EBX;
    ULONG ESP;
    ULONG EBP;
    ULONG ESI;
    ULONG EDI;
    ULONG EFlags;
    ULONG EIP;
    ULONG CSLim;		/* Byte Granular Limits */
    ULONG CSBase;		/* Byte Granular Base */
    UCHAR CSAcc;		/* Access Bytes */
    UCHAR CSAtr;		/* Attribute Bytes */
    USHORT CS;
    ULONG DSLim;
    ULONG DSBase;
    UCHAR DSAcc;
    UCHAR DSAtr;
    USHORT DS;
    ULONG ESLim;
    ULONG ESBase;
    UCHAR ESAcc;
    UCHAR ESAtr;
    USHORT ES;
    ULONG FSLim;
    ULONG FSBase;
    UCHAR FSAcc;
    UCHAR FSAtr;
    USHORT FS;
    ULONG GSLim;
    ULONG GSBase;
    UCHAR GSAcc;
    UCHAR GSAtr;
    USHORT GS;
    ULONG SSLim;
    ULONG SSBase;
    UCHAR SSAcc;
    UCHAR SSAtr;
    USHORT SS;
} tDbgBuf;

static VOID ListModules(VOID);
static VOID PrintMemoryAttributes(PVOID pvAddress, PSZ pszDesc);

static VOID WalkStack(PVOID pvStackBottom, PVOID pvStackTop, ULONG ulEBP, USHORT uSS, ULONG ulEIP, USHORT uCS);

#ifdef WANT_CODEVIEW
static INT Read16CodeView(INT fh, USHORT usSegNum, USHORT usOffset, CHAR *FileName);
#endif

static INT Read32PmDebug(INT fh, USHORT usSegNum, ULONG ulOffset, CHAR *pszFileName);
static APIRET PrintLineNum(CHAR *pszFileName, ULONG ulObjNum, ULONG ulOffset);
static VOID PrintSymbolFromSymFile(CHAR *pszSymFileName, ULONG ulObjNum, ULONG ulOffset);
static VOID PrintLocalVariables(ULONG ulStackOffset);
static BYTE *FormatVarValue(PVOID pVar, BYTE type);

typedef ULONG *_Seg16 PULONG16;

APIRET16 APIENTRY16 DOS16SIZESEG(USHORT Seg, PULONG16 Size);

typedef APIRET16(APIENTRY16 _PFN16)();

ULONG APIENTRY DosSelToFlat(ULONG);

//=== DosQueryProcess status interface ===

APIRET16 APIENTRY16 DOSQPROCSTATUS(ULONG * _Seg16 pBuf, USHORT cbBuf);

#if 0 // 06 Feb 08 SHL fixme to be gone now using bsedos.h definitions

#pragma pack(1)

typedef struct qsGrec_s
{
    ULONG cThrds;		/* number of threads in use */
    ULONG Reserved1;
    ULONG Reserved2;
} qsGrec_t;

/* Thread Record structure - Holds all per thread information. */
typedef struct qsTrec_s
{
    ULONG RecType;		/* Record Type */
    /* Thread rectype = 100 */
    USHORT tid;			/* thread ID */
    USHORT slot;		/* "unique" thread slot number */
    ULONG sleepid;		/* sleep id thread is sleeping on */
    ULONG priority;		/* thread priority */
    ULONG systime;		/* thread system time */
    ULONG usertime;		/* thread user time */
    UCHAR state;		/* thread state */
	PADCHAR;
	PADSHORT;
} qsTrec_t;

/* Process and Thread Data Section */
typedef struct qsPrec_s
{
    ULONG RecType;		/* type of record being processed */
    /* process rectype = 1       */
    qsTrec_t *pThrdRec;		/* ptr to 1st thread rec for this prc */
    USHORT pid;			/* process ID */
    USHORT ppid;		/* parent process ID */
    ULONG type;			/* process type */
    ULONG stat;			/* process status */
    ULONG sgid;			/* process screen group */
    USHORT hMte;		/* program module handle for process */
    USHORT cTCB;		/* # of TCBs in use in process */
    ULONG Reserved1;
    PVOID Reserved2;
    USHORT c16Sem;		/* # of 16 bit system sems in use by proc */
    USHORT cLib;		/* number of runtime linked libraries */
    USHORT cShrMem;		/* number of shared memory handles */
    USHORT Reserved3;
    USHORT *p16SemRec;		/* ptr to head of 16 bit sem inf for proc */
    USHORT *pLibRec;		/* ptr to list of runtime lib in use by */
    /*process */
    USHORT *pShrMemRec;		/* ptr to list of shared mem handles in */
    /* use by process */
    USHORT *Reserved4;
} qsPrec_t;

/* 16 Bit System Semaphore Section */
typedef struct qsS16Headrec_s
{
    ULONG RecType;		/* semaphore rectype = 3 */
    ULONG Reserved1;		/* overlays NextRec of 1st qsS16rec_t */
    ULONG Reserved2;
    ULONG S16TblOff;		/* index of first semaphore,SEE PSTAT OUTPUT */
    /* System Semaphore Information Section     */
} qsS16Headrec_t;

/* 16 bit System Semaphore Header Record Structure */
typedef struct qsS16rec_s
{
    ULONG NextRec;		/* offset to next record in buffer */
    UINT s_SysSemOwner;		/* thread owning this semaphore    */
    UCHAR s_SysSemFlag;		/* system semaphore flag bit field */
    UCHAR s_SysSemRefCnt;	/* number of references to this    */
				/* system semaphore                */
    UCHAR s_SysSemProcCnt;	/*number of requests by sem owner  */
    UCHAR Reserved1;
    ULONG Reserved2;
    UINT Reserved3;
    CHAR SemName[1];		/* start of semaphore name string */
} qsS16rec_t;

/* Executable Module Section */
typedef struct qsLrec_s
{
    PVOID pNextRec;		/* pointer to next record in buffer */
    USHORT hmte;		/* handle for this mte */
    USHORT Reserved1;		/* Reserved */
    ULONG ctImpMod;		/* # of imported modules in table */
    ULONG Reserved2;		/* Reserved */
    /* qsLObjrec_t * Reserved3;    Reserved */
    ULONG *Reserved3;		/* Reserved */
    UCHAR *pName;		/* ptr to name string following stru */
} qsLrec_t;

/* Shared Memory Segment Section */
typedef struct qsMrec_s
{
    struct qsMrec_s *MemNextRec; /* offset to next record in buffer */
    USHORT hmem;		/* handle for shared memory */
    USHORT sel;			/* shared memory selector */
    USHORT refcnt;		/* reference count */
    CHAR Memname[1];		/* start of shared memory name string */
} qsMrec_t;

/* Pointer Record Section */
typedef struct qsPtrRec_s
{
    qsGrec_t *pGlobalRec;	/* ptr to the global data section */
    qsPrec_t *pProcRec;		/* ptr to process record section  */
    qsS16Headrec_t *p16SemRec;	/* ptr to 16 bit sem section      */
    PVOID Reserved;		/* a reserved area                */
    qsMrec_t *pShrMemRec;	/* ptr to shared mem section      */
    qsLrec_t *pLibRec;		/*ptr to exe module record section */
} qsPtrRec_t;

#endif // 06 Feb 08 SHL fixme to be gone now using bsedos.h definitions

//=== end of DosQueryProcess status interface ===

USHORT Selector;

APIRET16 APIENTRY16 DOS16ALLOCSEG(USHORT cbSize,	/* number of bytes requested                   */
				  USHORT * _Seg16 pSel,	/* sector allocated (returned)                 */
				  USHORT fsAlloc);	/* sharing attributes of the allocated segment */

//=== dis386 interface ===

// default packing is 4 for VAC

#pragma pack(1)				// 06 Feb 08 SHL

typedef struct
{
    SHORT ilen;			/* Instruction length */
    LONG rref;			/* Value of any IP relative storage reference */
    USHORT sel;			/* Selector of any CS:eIP storage reference.   */
    LONG poff;			/* eIP value of any CS:eIP storage reference. */
    CHAR longoper;		/* YES/NO value. Is instr in 32 bit operand mode? * */
    CHAR longaddr;		/* YES/NO value. Is instr in 32 bit address mode? * */
    CHAR buf[40];		/* String holding disassembled instruction * */
} *_Seg16 RETURN_FROM_DISASM;

#pragma pack()				// 06 Feb 08 SHL

RETURN_FROM_DISASM CDECL16 DISASM(CHAR * _Seg16 pSource, USHORT usIPvalue, USHORT usSegSize);
RETURN_FROM_DISASM pDis386Data;

//=== end of dis386 interface ===

PVOID pvDis386Buffer;

static ULONG aulOSVersion[2];

BYTE *type_name[] =
{
    "8 bit signed                     ",
    "16 bit signed                    ",
    "32 bit signed                    ",
    "Unknown (0x83)                   ",
    "8 bit unsigned                   ",
    "16 bit unsigned                  ",
    "32 bit unsigned                  ",
    "Unknown (0x87)                   ",
    "32 bit real                      ",
    "64 bit real                      ",
    "80 bit real                      ",
    "Unknown (0x8B)                   ",
    "64 bit complex                   ",
    "128 bit complex                  ",
    "160 bit complex                  ",
    "Unknown (0x8F)                   ",
    "8 bit boolean                    ",
    "16 bit boolean                   ",
    "32 bit boolean                   ",
    "Unknown (0x93)                   ",
    "8 bit character                  ",
    "16 bit characters                ",
    "32 bit characters                ",
    "void                             ",
    "15 bit unsigned                  ",
    "24 bit unsigned                  ",
    "31 bit unsigned                  ",
    "Unknown (0x9B)                   ",
    "Unknown (0x9C)                   ",
    "Unknown (0x9D)                   ",
    "Unknown (0x9E)                   ",
    "Unknown (0x9F)                   ",
    "near pointer to 8 bit signed     ",
    "near pointer to 16 bit signed    ",
    "near pointer to 32 bit signed    ",
    "Unknown (0xA3)                   ",
    "near pointer to 8 bit unsigned   ",
    "near pointer to 16 bit unsigned  ",
    "near pointer to 32 bit unsigned  ",
    "Unknown (0xA7)                   ",
    "near pointer to 32 bit real      ",
    "near pointer to 64 bit real      ",
    "near pointer to 80 bit real      ",
    "Unknown (0xAB)                   ",
    "near pointer to 64 bit complex   ",
    "near pointer to 128 bit complex  ",
    "near pointer to 160 bit complex  ",
    "Unknown (0xAF)                   ",
    "near pointer to 8 bit boolean    ",
    "near pointer to 16 bit boolean   ",
    "near pointer to 32 bit boolean   ",
    "Unknown (0xB3)                   ",
    "near pointer to 8 bit character  ",
    "near pointer to 16 bit characters",
    "near pointer to 32 bit characters",
    "near pointer to void             ",
    "near pointer to 15 bit unsigned  ",
    "near pointer to 24 bit unsigned  ",
    "near pointer to 31 bit unsigned  ",
    "Unknown (0xBB)                   ",
    "Unknown (0xBC)                   ",
    "Unknown (0xBD)                   ",
    "Unknown (0xBE)                   ",
    "Unknown (0xBF)                   ",
    "far pointer to 8 bit signed      ",
    "far pointer to 16 bit signed     ",
    "far pointer to 32 bit signed     ",
    "Unknown (0xC3)                   ",
    "far pointer to 8 bit unsigned    ",
    "far pointer to 16 bit unsigned   ",
    "far pointer to 32 bit unsigned   ",
    "Unknown (0xC7)                   ",
    "far pointer to 32 bit real       ",
    "far pointer to 64 bit real       ",
    "far pointer to 80 bit real       ",
    "Unknown (0xCB)                   ",
    "far pointer to 64 bit complex    ",
    "far pointer to 128 bit complex   ",
    "far pointer to 160 bit complex   ",
    "Unknown (0xCF)                   ",
    "far pointer to 8 bit boolean     ",
    "far pointer to 16 bit boolean    ",
    "far pointer to 32 bit boolean    ",
    "Unknown (0xD3)                   ",
    "far pointer to 8 bit character   ",
    "far pointer to 16 bit characters ",
    "far pointer to 32 bit characters ",
    "far pointer to void              ",
    "far pointer to 15 bit unsigned   ",
    "far pointer to 24 bit unsigned   ",
    "far pointer to 31 bit unsigned   ",
};

typedef _PFN16 *_Seg16 PFN16;

static BOOL fInForceExit = FALSE;

// Statics that could be auto variables

static HMODULE hMod;
static ULONG ulObjNum;
static ULONG ulOffset;
static CHAR szBuffer[CCHMAXPATH];

static CHAR szModName[CCHMAXPATH];
static CHAR szFileName[CCHMAXPATH];
static ULONG ulSize;
static ULONG ulAttr;
static ULONG ulFlags;
static ULONG ul;
static PSZ psz;
static USHORT us;

/**
 * Exception handler called by application
 */


static ULONG APIENTRY HandleFatalException(PEXCEPTIONREPORTRECORD pERepRec,
					   PEXCEPTIONREGISTRATIONRECORD pERegRec,
					   PCONTEXTRECORD pCtxRec,
					   PVOID p);

// Thanks to John Currier :
// Do not call 16 bit code in MyHandler function to prevent call
// to __EDCThunkProlog and problems in guard page exception handling
// Also reduce the stack size to 1K for true 16 bit calls.
// 16 bit calls thunk will now only occur on fatal exceptions

#pragma stack16(1024)

//== MyHandler() Per thread exception handler entry ==

ULONG APIENTRY MyHandler(PEXCEPTIONREPORTRECORD pERepRec,
			 PEXCEPTIONREGISTRATIONRECORD pERegRec,
			 PCONTEXTRECORD pCtxRec,
			 PVOID p)
{
    ULONG rc = XCPT_CONTINUE_SEARCH;

    if ((pERepRec->ExceptionNum & XCPT_SEVERITY_CODE) == XCPT_FATAL_EXCEPTION)
    {
	if (pERepRec->ExceptionNum != XCPT_PROCESS_TERMINATE &&
	    pERepRec->ExceptionNum != XCPT_UNWIND &&
	    pERepRec->ExceptionNum != XCPT_SIGNAL &&
	    pERepRec->ExceptionNum != XCPT_BREAKPOINT &&
	    pERepRec->ExceptionNum != XCPT_SINGLE_STEP &&
	    pERepRec->ExceptionNum != XCPT_ASYNC_PROCESS_TERMINATE)
	{
	    // If not one of the above handle here
	    rc = HandleFatalException(pERepRec, pERegRec, pCtxRec, p);
	}
    }

    return rc;
}

//== HandleFatalException() exception handler worker ==

static ULONG APIENTRY HandleFatalException(PEXCEPTIONREPORTRECORD pERepRec,
					   PEXCEPTIONREGISTRATIONRECORD pERegRec,
					   PCONTEXTRECORD pCtxRec,
					   PVOID p)
{
    PUCHAR puchValidStackBottom;
    PUCHAR puchStackPtr;
    // ULONG ulSize;			// 10 Oct 07 SHL
    // ULONG ulFlags;			// 10 Oct 07 SHL
    // ULONG ulAttr;			// 10 Oct 07 SHL
    ULONG ulCSSize;
    APIRET rc;
    APIRET semrc;
    APIRET16 rc16;
    PTIB ptib;
    PPIB ppib;
    USHORT usMod16;
    USHORT us;
    ULONG ulNest;
    UCHAR szTrapFile[20];
    tDbgBuf DbgBuf;
    // CHAR szModName[CCHMAXPATH];	// 10 Oct 07 SHL
    ULONG ulEIP;
    ULONG ulEBP;
    USHORT usCS;
    USHORT usSS;
    USHORT fisBigSeg;			// 10 Oct 07 SHL
    USHORT usDupReported;
    PVOID pv;
    UCHAR abOldStuff[16];
    CHAR szTranslate[17];

    /* Do not recurse into Trapper (John Currier) */
    static BOOL fAlreadyTrapped = FALSE;

    if (fInForceExit)
	return XCPT_CONTINUE_SEARCH;

    if ((pERepRec->ExceptionNum & XCPT_SEVERITY_CODE) != XCPT_FATAL_EXCEPTION)
    {
	/* printf("Other non fatal exception %8.8lx ",pERepRec->ExceptionNum); */
	/* printf("At address                %8.8lx\n",pERepRec->ExceptionAddress); */
    }
    else {
	if ((pERepRec->ExceptionNum != XCPT_PROCESS_TERMINATE) &&
	    (pERepRec->ExceptionNum != XCPT_UNWIND) &&
	    (pERepRec->ExceptionNum != XCPT_SIGNAL) &&
	    (pERepRec->ExceptionNum != XCPT_ASYNC_PROCESS_TERMINATE))
	{
	    // Got process exception
	    DosEnterMustComplete(&ulNest);
	    rc = DosGetInfoBlocks(&ptib, &ppib);
	    if (rc == NO_ERROR) {
		sprintf(szTrapFile, "%04X_%d.TRP",
			ppib->pib_ulpid, ptib->tib_ptib2->tib2_ultid);
	    }
	    else
		sprintf(szTrapFile, "TRAP.TRP");	// Can not get PID - use generic name

	    printf("Creating %s\n", szTrapFile);
	    hTrap = fopen(szTrapFile, "a");
	    if (hTrap == NULL) {
		printf("Can not append to %s - writing to stdout (%d)\n", szTrapFile, errno);
		hTrap = stdout;
	    }

	    rc = DosError(FERR_DISABLEEXCEPTION | FERR_DISABLEHARDERR);
	    setbuf(hTrap, NULL);
	    fputs("--------------------------\n",hTrap);
	    fprintf(hTrap, "Exception %8.8lX occurred", pERepRec->ExceptionNum);
	    fprintf(hTrap, " at %s ", _strtime(szBuffer));
	    fprintf(hTrap, " %s\n", _strdate(szBuffer));

	    if (pERepRec->ExceptionNum == XCPT_ACCESS_VIOLATION) {
		psz = NULL;
		switch (pERepRec->ExceptionInfo[0]) {
		case XCPT_READ_ACCESS:
		    fprintf(hTrap, "Attempting to read from %8.8lX\n", pERepRec->ExceptionInfo[1]);
		    break;
		case XCPT_WRITE_ACCESS:
		    fprintf(hTrap, "Attempting to write to %8.8lX\n", pERepRec->ExceptionInfo[1]);
		    break;
		case XCPT_EXECUTE_ACCESS:
		    fprintf(hTrap, "Attempting to execute at %8.8lX\n", pERepRec->ExceptionInfo[1]);
		    break;
		case XCPT_SPACE_ACCESS:
		    /* Thanks to John Currier              */
		    /* It looks like this is off by one... - fixme to know why */
		    fprintf(hTrap, "Attempt to access beyond selector %8.8X limit",
			    pERepRec->ExceptionInfo[1] ?
			      pERepRec->ExceptionInfo[1] + 1 : 0);
		    break;
		case XCPT_LIMIT_ACCESS:
		    psz = "Limit access fault\n";
		    break;
		case XCPT_UNKNOWN_ACCESS:
		    psz = "Unknown access fault\n";
		    break;
		default:
		    psz = "Other unknown access fault\n";
		} /* switch */
		if (psz)
		    fputs(psz, hTrap);
	    } /* if access violation */

	    fputc('\n', hTrap);

	    /* John Currier's recursion prevention */
	    if (fAlreadyTrapped) {
		fputs("Exception handler trapped - aborting evaluation!\n",hTrap);
		if (hTrap != stderr)
		    fclose(hTrap);
		DosExitMustComplete(&ulNest);
		DosUnsetExceptionHandler(pERegRec);
		return XCPT_CONTINUE_SEARCH;
	    }
	    fAlreadyTrapped = TRUE;
	    /* end  John Currier's recursion prevention */

	    rc = DosQuerySysInfo(QSV_VERSION_MAJOR, QSV_VERSION_MINOR,
				 aulOSVersion, sizeof(aulOSVersion));
	    if (rc == NO_ERROR &&
		aulOSVersion[0] >= 20 &&
		aulOSVersion[1] >= 10) {
		/* version must be over 2.1 for DosQueryModFromEIP */
		fprintf(hTrap, "eCS/OS2 version %d.%d; exceptq version " EXCEPTQ_VERSION " built "__DATE__ "\n",
			aulOSVersion[0] / 10, aulOSVersion[1]);
		rc = DosQueryModFromEIP(&hMod, &ulObjNum, CCHMAXPATH,
					szModName, &ulOffset,
					(ULONG)pERepRec->ExceptionAddress);
		if (rc != NO_ERROR)
		    fputs("Invalid execution address\n", hTrap);
		else {
		    fprintf(hTrap, "Failing code module internal name %s\n", szModName);
		    rc = DosQueryModuleName(hMod, CCHMAXPATH, szFileName);
		    fprintf(hTrap, "Failing code module file name %s\n",
			    rc == NO_ERROR ? szFileName : szModName);
		    fprintf(hTrap, "Failing code at %8.8X (%4.4X:%8.8X)\n",
			    (ULONG)pERepRec->ExceptionAddress, ulObjNum + 1, ulOffset);
		    if (rc == NO_ERROR) {
			fputs("\n     File      Line#  Public Symbol\n", hTrap);
			fputs(  " ÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ\n", hTrap);
			rc = PrintLineNum(szFileName, ulObjNum, ulOffset);
			if (rc == NO_ERROR)
			    PrintLocalVariables(pCtxRec->ctx_RegEbp);
			if (rc != NO_ERROR && strlen(szFileName) > 3) {
			    /* No embedded debug or DBG file, try symbol file */
			    strcpy(szFileName + strlen(szFileName) - 3, "SYM");
			    PrintSymbolFromSymFile(szFileName, ulObjNum, ulOffset);
			}
		    }
		}
	    }

	    fputs("\nÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿\n",hTrap);

	    if (pCtxRec->ContextFlags & CONTEXT_INTEGER) {
		// 11 Oct 07 SHL fixme to optimize
		fprintf(hTrap, "³ EAX : %8.8lX ", pCtxRec->ctx_RegEax);
		fprintf(hTrap, "EBX  : %8.8lX ", pCtxRec->ctx_RegEbx);
		fprintf(hTrap, "ECX : %8.8lX ", pCtxRec->ctx_RegEcx);
		fprintf(hTrap, "EDX  : %8.8lX ³\n", pCtxRec->ctx_RegEdx);
		fprintf(hTrap, "³ ESI : %8.8lX ", pCtxRec->ctx_RegEsi);
		fprintf(hTrap, "EDI  : %8.8lX                                ³\n", pCtxRec->ctx_RegEdx);
	    }
	    if (pCtxRec->ContextFlags & CONTEXT_CONTROL) {
		fprintf(hTrap, "³ ESP : %8.8lX ", pCtxRec->ctx_RegEsp);
		fprintf(hTrap, "EBP  : %8.8lX ", pCtxRec->ctx_RegEbp);
		fprintf(hTrap, "EIP : %8.8lX ", pCtxRec->ctx_RegEip);
		fprintf(hTrap, "EFLG : %8.8lX ³\n", pCtxRec->ctx_EFlags);

		fprintf(hTrap, "³ CS  : %4.4lX     ", pCtxRec->ctx_SegCs);

		rc16 = DOS16SIZESEG((USHORT)pCtxRec->ctx_SegCs, &ulCSSize);
		if (rc16 == NO_ERROR)
		    fprintf(hTrap, "CSLIM: %8.8lX ", ulCSSize);
		else if (pCtxRec->ctx_SegCs == FLATCS) {
		    ulCSSize = 0x1FFFFFFFL;	// 512MB fixme?
		    fprintf(hTrap, "CSLIM: %8.8lX ", ulCSSize);
		}
		else {
		    ulCSSize = 0;
		    fprintf(hTrap, "CSLIM: ???????? ", ulCSSize);
		}

		fprintf(hTrap, "SS  : %4.4lX     ", pCtxRec->ctx_SegSs);
		rc16 = DOS16SIZESEG((USHORT)pCtxRec->ctx_SegSs, &ulSize);
		if (rc16 == NO_ERROR)
		    fprintf(hTrap, "SSLIM: %8.8lX ³\n", ulSize);
		else if (pCtxRec->ctx_SegSs == FLATDS) {
		    fprintf(hTrap, "SSLIM: %8.8lX ³\n", 0x1FFFFFFFL);	// 512MB fixme?
		}
		else
		    fputs("SSLIM: ???????? ³\n",hTrap);
	    }
	    if (pCtxRec->ContextFlags & CONTEXT_SEGMENTS) {
		fprintf(hTrap, "³ DS  : %4.4lX     ", pCtxRec->ctx_SegDs);
		fprintf(hTrap, "ES   : %4.4lX     ", pCtxRec->ctx_SegEs);
		fprintf(hTrap, "FS  : %4.4lX     ", pCtxRec->ctx_SegFs);
		fprintf(hTrap, "GS   : %4.4lX     ³\n", pCtxRec->ctx_SegGs);
	    }

	    fputs("ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ\n",hTrap);

	    if (~pCtxRec->ContextFlags & CONTEXT_CONTROL)
		fputs("\nControl context not available\n",hTrap);
	    else {
		// fixme to DosLoadModule dis386
		// fixme to check big seg better - check flatcs?
		fisBigSeg = pCtxRec->ctx_SegCs == FLATCS || pCtxRec->ctx_RegEip > 0x00010000;
		if (fisBigSeg) {
		    // 32-bit code seg
		    /* Avoid traps in 16:16 Disasm DLL */
		    if (DosAllocMem(&pvDis386Buffer, 0x100, fALLOC) == NO_ERROR) {
			ulSize = 0x100;
			rc = DosQueryMem((PVOID)pCtxRec->ctx_RegEip, &ulSize, &ulAttr);
			if (rc == NO_ERROR &&
			    (ulAttr & (PAG_READ | PAG_EXECUTE)) == (PAG_READ | PAG_EXECUTE)) {
			    memcpy(pvDis386Buffer, (PVOID)pCtxRec->ctx_RegEip, ulSize);
			    pDis386Data = DISASM(pvDis386Buffer,
						 (USHORT)pCtxRec->ctx_RegEip,
						 fisBigSeg);
			    fprintf(hTrap, "\nFailing instruction at CS:EIP %4.4X:%8.8X is %s\n",
				    pCtxRec->ctx_SegCs,
				    pCtxRec->ctx_RegEip,
				    pDis386Data->buf);
			}
			else {
			    fprintf(hTrap, "\nCan not disassemble instruction at CS:EIP %4.4X:%8.8X\n",
				    pCtxRec->ctx_SegCs, pCtxRec->ctx_RegEip);
			}
		    }

		    fputs("\nÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿\n", hTrap);
		    fputs("³ Register content analysis          ³\n", hTrap);
		    fputs("ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´\n", hTrap);
		    PrintMemoryAttributes((PVOID)pCtxRec->ctx_RegEax, "EAX");
		    PrintMemoryAttributes((PVOID)pCtxRec->ctx_RegEbx, "EBX");
		    PrintMemoryAttributes((PVOID)pCtxRec->ctx_RegEcx, "ECX");
		    PrintMemoryAttributes((PVOID)pCtxRec->ctx_RegEdx, "EDX");
		    PrintMemoryAttributes((PVOID)pCtxRec->ctx_RegEdi, "EDI");
		    PrintMemoryAttributes((PVOID)pCtxRec->ctx_RegEsi, "ESI");
		    fputs("ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ\n",hTrap);
		}
		else {
		    // 16-bit code seg
		    if (ulCSSize > pCtxRec->ctx_RegEip) {
			pDis386Data = DISASM(MAKE16P(pCtxRec->ctx_SegCs,
						     pCtxRec->ctx_RegEip),
					     (USHORT)pCtxRec->ctx_RegEip,
					     fisBigSeg);
			fprintf(hTrap, "\nFailing instruction at CS:IP %4.4X:%4.4X is %s\n",
				pCtxRec->ctx_SegCs,
				pCtxRec->ctx_RegEip,
				pDis386Data->buf);
		    }
		    else {
			fprintf(hTrap, "\nCan not disassemble instruction at CS:IP %4.4X:%4.4X\n",
				pCtxRec->ctx_SegCs, pCtxRec->ctx_RegEip);
		    }

		    fputs("\nÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿\n", hTrap);
		    fputs("³ Source Destination registers pair analysis ³\n", hTrap);
		    fputs("ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´\n", hTrap);
		    rc16 = DOS16SIZESEG((USHORT)pCtxRec->ctx_SegDs, &ulSize);
		    if (rc16 == NO_ERROR) {
			if ((USHORT)ulSize < (USHORT)pCtxRec->ctx_RegEsi)
			    fputs("³ DS:SI points outside Data Segment          ³\n", hTrap);
			else
			    fputs("³ DS:SI is a valid source                    ³\n", hTrap);
		    }
		    else
			fputs("³ DS (Data Segment) Is Invalid               ³\n", hTrap);

		    rc16 = DOS16SIZESEG((USHORT)pCtxRec->ctx_SegEs, &ulSize);
		    if (rc16 == NO_ERROR) {
			if ((USHORT)ulSize < (USHORT)pCtxRec->ctx_RegEdi)
			    fputs("³ ES:DI points outside Extra Segment         ³\n", hTrap);
			else
			    fputs("³ ES:DI is a valid destination               ³\n", hTrap);
		    }
		    else
			fputs("³ ES (Extra Segment) Is Invalid              ³\n", hTrap);

		    fputs("ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ\n", hTrap);
		} /* if 16-bit seg */

		rc = DosGetInfoBlocks(&ptib, &ppib);
		if (rc == NO_ERROR) {
		    CHAR szFormat[10];
		    fprintf(hTrap, "\nThread slot %lX (%lu); Id %lX; Priority %p\n",
			    ptib->tib_ordinal,
			    ptib->tib_ordinal,
			    ptib->tib_ptib2->tib2_ultid,
			    ptib->tib_ptib2->tib2_ulpri);
		    pv = ptib->tib_pstack;
		    sprintf(szFormat, "%8.8lX", pv);
		    fprintf(hTrap, "Stack bottom %8.8lX (%4.4s:%4.4s); ", ptib->tib_pstack, szFormat, szFormat + 4);
		    pv = ptib->tib_pstacklimit;
		    sprintf(szFormat, "%8.8lX", pv);
		    fprintf(hTrap, "Stack top %8.8lX (%4.4s:%4.4s)\n", ptib->tib_pstacklimit, szFormat, szFormat + 4);
		    fprintf(hTrap, "Process id %4.4X (%lu); ",
			    ppib->pib_ulpid, ppib->pib_ulpid);

		    rc = DosQueryModuleName(ppib->pib_hmte, CCHMAXPATH, szFileName);
		    fprintf(hTrap, "Executable name %s\n",
			    rc == NO_ERROR ? szFileName : "N/A");

		    if (pCtxRec->ContextFlags & CONTEXT_CONTROL) {
			ulEIP = pCtxRec->ctx_RegEip;
			usCS = pCtxRec->ctx_SegCs;
			ulEBP = pCtxRec->ctx_RegEbp;
			usSS = pCtxRec->ctx_SegSs;
		    }
		    else {
			ulEIP = (ULONG)pERepRec->ExceptionAddress,
			usCS = 0;	// fixme guess better
			ulEBP = (ULONG)ptib->tib_pstack;	// fixme to guess better
			usSS = 0;	// fixme guess better
		    }

		    // fixme to bypass if insufficient context
		    WalkStack(ptib->tib_pstack,
			      ptib->tib_pstacklimit,
			      ulEBP,
			      usSS,
			      ulEIP,
			      usCS);

		    // Find accessible stack range

		    /* round to start of page to check first stack valid page - fixme? */
		    /* Thanks to John Currier for pointing me the guard page problem */
		    for (puchStackPtr = ((PUCHAR)ptib->tib_pstacklimit);
			 puchStackPtr -= 0x1000;
			 puchStackPtr >= (PUCHAR)ptib->tib_pstack)
		    {
			ulSize = 0x1000;
			rc = DosQueryMem(puchStackPtr, &ulSize, &ulAttr);
			if (rc != NO_ERROR ||
			    ~ulAttr & PAG_COMMIT ||
			    ~ulAttr & PAG_READ)
			{
			   puchStackPtr += 0x1000;
			   break;
			}
		    }

		    if (puchStackPtr > (PUCHAR)ptib->tib_pstacklimit)
			fputs("\n/*----- Stack can not be accessed ---*/\n",hTrap);
		    else {

			BOOL is32Bit = usCS == FLATCS;
			abOldStuff[0] = ~(*puchStackPtr);	/* Ensure first line is printed */
			fprintf(hTrap, "\nAccessible Stack bottom at %p\n", puchStackPtr);

			puchValidStackBottom = puchStackPtr;

			// 10 Oct 07 SHL Display labels on stack

			fputs("\nLabels on Stack\n",hTrap);
			fputs("                                               Source     Line    Nearest\n", hTrap);
			fputs("  Stack    Address   Module    Obj:Offset       File      Numbr  Public Symbol\n", hTrap);
			fputs(" ÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ\n", hTrap);

			// Optimize start location
			puchStackPtr = puchValidStackBottom;
			if (pCtxRec->ContextFlags & CONTEXT_CONTROL) {
			    if ((pCtxRec->ctx_RegEbp & 0x3) == 0 &&
				     pCtxRec->ctx_RegEbp > (ULONG)puchStackPtr &&
				     (PVOID)pCtxRec->ctx_RegEbp < ptib->tib_pstacklimit)
			    {
				puchStackPtr = (PUCHAR)pCtxRec->ctx_RegEbp;
			    }
			    else if ((pCtxRec->ctx_RegEsp & 0x3) == 0 &&
				pCtxRec->ctx_RegEsp > (ULONG)puchStackPtr &&
				(PVOID)pCtxRec->ctx_RegEsp < ptib->tib_pstacklimit)
			    {
				puchStackPtr = (PUCHAR)pCtxRec->ctx_RegEsp;
			    }
			}

			for (; puchStackPtr < (PUCHAR)ptib->tib_pstacklimit;
			     puchStackPtr += 4)
			{
			    ul = *(PULONG)puchStackPtr;
			    if (ul < 0x10000L)
				continue;	// Check fast
			    ulSize = 4;
			    rc = DosQueryMem((PVOID)ul, &ulSize, &ulAttr);
			    if (rc != NO_ERROR || ~ulAttr & PAG_COMMIT || ~ulAttr & PAG_EXECUTE)
				continue;
			    rc = DosQueryModFromEIP(&hMod, &ulObjNum, CCHMAXPATH,
						    szModName, &ulOffset, ul);
			    if (rc != NO_ERROR)
				continue;
			    if (ulOffset == 0xffffffff)
				continue;
			    fprintf(hTrap, " %08X %08X %-8.8s %04X:%08X",
				    puchStackPtr,
				    ul,
				    szModName,
				    ulObjNum + 1,
				    ulOffset);
			    rc = DosQueryModuleName(hMod, CCHMAXPATH, szFileName);
			    if (rc != NO_ERROR) {
				fputc('\n', hTrap);
				continue;
			    }
			    rc = PrintLineNum(szFileName, ulObjNum, ulOffset);
			    /* if no embedded debug or DBG file try with symbol files */
			    if (rc != NO_ERROR) {
				/* Form .sym file name */
				strcpy(szFileName + strlen(szFileName) - 3, "SYM");
				PrintSymbolFromSymFile(szFileName, ulObjNum, ulOffset);
			    }
			} // for

			// Dump stack content
			// Format left side as dwords for 32-bit code, words for 16-bit code
			// Format right side as masked bytes

			usMod16 = 0;
			*szTranslate = 0;
			fputs("\n/*----- Stack Bottom ---*/\n",hTrap);

			for (puchStackPtr = puchValidStackBottom;
			     puchStackPtr < (PUCHAR)ptib->tib_pstacklimit;)
			{
			    if (usMod16 == 0) {
				/* Starting new output line */
				if (memcmp(abOldStuff, puchStackPtr, 16)) {
				    /* Save for dup checking */
				    memcpy(abOldStuff, puchStackPtr, 16);
				    usDupReported = 0;
				}
				else {
				    /* Suppress duplicate data */
				    if (usDupReported == 0) {
					usDupReported = 1;
					fprintf(hTrap, "%s%s\n %8.8X :",
						*szTranslate != '\n' ? "  " : "",
						szTranslate,
						puchStackPtr);
					fputs("  lines not printed same as above", hTrap);
					strcpy(szTranslate, "\n");
				    }
				    puchStackPtr += 16;
				    continue;
				}

				szTranslate[16] = 0;
				fprintf(hTrap, "%s%s\n %8.8X :",
					*szTranslate && *szTranslate != '\n' ? "  " : "",
					szTranslate,
					puchStackPtr);
				*szTranslate = 0;
			    } /* if usMod16 */

			    if (is32Bit)
			      fprintf(hTrap, "%08.8X ", *(ULONG*)puchStackPtr);
			    else
			      fprintf(hTrap, "%04.4X ", *(USHORT*)puchStackPtr);

			    for (us = 0 ; us < (is32Bit ? 4 : 2); us++) {
			      if (isprint(*puchStackPtr) && *puchStackPtr >= 0x20)
				  szTranslate[usMod16] = *puchStackPtr;
			      else
				  szTranslate[usMod16] = '.';
			      usMod16++;
			      puchStackPtr++;
			    }

			    usMod16 &= 0xf;

			} /* for */

			fprintf(hTrap, "%s%s\n\n/*----- Stack Top -----*/\n",
					*szTranslate != '\n' ? "  " : "",
					szTranslate);

		    } /* if range OK */


		    ListModules();

		} /* if no error */

	    } /* if CONTEXT_CONTROL */

	    if (hTrap != stdout)
		fclose(hTrap);

	    DosExitMustComplete(&ulNest);
	    rc = DosUnsetExceptionHandler(pERegRec);
	} /* if fatal */
    }

    return XCPT_CONTINUE_SEARCH;

} // HandleFatalException

//== SETEXCEPT() Define exception handler ==

APIRET16 APIENTRY16 SETEXCEPT(PEXCEPTIONREGISTRATIONRECORD _Seg16 pxcpthand)
{
    APIRET rc;

    rc = DosError(FERR_DISABLEEXCEPTION | FERR_DISABLEHARDERR);
    printf("DosError rc %d\n", rc);
    pxcpthand->prev_structure = 0;
    pxcpthand->ExceptionHandler = &MyHandler;
    rc = DosSetExceptionHandler(pxcpthand);
    printf("DosSetExceptionHandler rc %d\n", rc);

    return NO_ERROR;
}

//== UNSETEXCEPT() Unset exception hanlder ==

APIRET16 APIENTRY16 UNSETEXCEPT(PEXCEPTIONREGISTRATIONRECORD _Seg16 pxcpthand)
{
    APIRET rc;

    rc = DosUnsetExceptionHandler(pxcpthand);
    printf("DosUnsetExceptionHandler rc %d\n", rc);
    return NO_ERROR;
}

// #define USE_DOSDEBUG

// qsPtrRec_t *pRec;			// 06 Feb 08 SHL
QSPTRREC *pRec;

#ifdef USE_DOSDEBUG

//== ListModules() List loaded modules using DosDebug ==

static VOID ListModules(VOID)
{
    APIRET rc;
    APIRET16 rc16;
    qsLrec_t *pLib;
    RESULTCODES ReturnCodes;

    UCHAR szLoadError[40];	/*DosExecPGM buffer */
    UCHAR *szProcessName = "DEBUGGEE.EXE";

    rc16 = DOS16ALLOCSEG(0xFFFF, &Selector, 0);
    if (rc16 != NO_ERROR)
	fprintf(hTrap, "DosAllocSeg Failed %hd\n", rc16);
    else {
	ULONG *pBuf;
	pBuf = MAKEP(Selector, 0);
	rc16 = DOSQPROCSTATUS(pBuf, 0xFFFF);
	if (rc16 != NO_ERROR)
	    fprintf(hTrap, "DosQProcStatus Failed %hd\n", rc16);
	else {
	    rc = DosExecPgm(szLoadError,		/* Object name buffer */
			    sizeof(szLoadError),	/* Length of object name buffer */
			    EXEC_TRACE,	/* Asynchronous/Trace flags */
			    "Debug",	/* Argument string */
			    NULL,	/* Environment string */
			    &ReturnCodes,	/* Termination codes */
			    szProcessName);	/* Program file name */
	    if (rc != NO_ERROR) {
		fprintf(hTrap, "rc %d; Process id %d; Return code %d \n",
			rc,
			ReturnCodes.codeTerminate,
			ReturnCodes.codeResult);
		return;
	    }
	    fprintf(hTrap, "Connecting  to PID %d\n", ReturnCodes.codeTerminate);
	    DbgBuf.Cmd = DBG_C_Connect;	/* Indicate that a Connect is requested */
	    DbgBuf.Pid = ReturnCodes.codeTerminate;
	    DbgBuf.Tid = 0;
	    DbgBuf.Value = DBG_L_386;
	    rc = DosDebug(&DbgBuf);
	    if (rc != NO_ERROR) {
		fprintf(hTrap, "DosDebug error return code = %ld Note %8.8lX\n", rc, DbgBuf.Cmd);
		fprintf(hTrap, "Value          = %8.8lX %ld\n", DbgBuf.Value, DbgBuf.Value);
	    }
	    fprintf(hTrap, "Connected to PID %d\n", ReturnCodes.codeTerminate);

	    pRec = (_QSPTRREC *) pBuf;
	    pLib = pRec->pLibRec;
	    while (pLib) {
		GetObjects(&DbgBuf, pLib->hmte, pLib->pName);
		pLib = pLib->pNextRec;
	    }				/* endwhile */
	}
    }

} // ListModules

//== GetObjects() Lists object for module using DosDebug ==

static VOID GetObjects(tDbgBuf *pDbgBuf, HMODULE hMte, PSZ pName)
{
    APIRET rc;
    UINT uObjNum;

    pDbgBuf->MTE = (ULONG) hMte;
    rc = NO_ERROR;
    fprintf(hTrap, "DLL %s Handle %d\n", pName, hMte);
    fputs("Object Number    Address    Length     Flags      Type\n", hTrap);

    for (uObjNum = 1; uObjNum < 256; uObjNum++) {
	pDbgBuf->Cmd = DBG_C_NumToAddr;
	pDbgBuf->Pid = ReturnCodes.codeTerminate;
	pDbgBuf->Value = uObjNum;	/* Get nth object address in module with given MTE */
	pDbgBuf->Buffer = 0;
	pDbgBuf->Len = 0;
	rc = DosDebug(pDbgBuf);
	if (rc == NO_ERROR && pDbgBuf->Cmd == NO_ERROR) {
	    // ULONG ulSize;		// 10 Oct 07 SHL
	    APIRET16 rc16;

	    pDbgBuf->Len = 0;
	    pDbgBuf->Value = 0;
	    if (pDbgBuf->Addr != 0) {
		pDbgBuf->Cmd = DBG_C_AddrToObject;
		pDbgBuf->Pid = ReturnCodes.codeTerminate;
		rc = DosDebug(pDbgBuf);
		// 17 Jul 07 SHL
		if (rc != NO_ERROR || pDbgBuf->Cmd != NO_ERROR) {
		    pDbgBuf->Len = 0;
		    pDbgBuf->Value = 0;
		}
	    }
	    fprintf(hTrap, "      % 6.6d    %8.8lX   %8.8lX   %8.8lX ", uObjNum,
		    pDbgBuf->Addr, pDbgBuf->Len, pDbgBuf->Value);
	    if (pDbgBuf->Addr != 0) {
		// fixme to know if DOS16SIZESEG really useful here
		rc16 = DOS16SIZESEG(SELECTOROF(pDbgBuf->Addr), &ulSize);
		if (rc16 == NO_ERROR && (~pDbgBuf->Value & OBJBIGDEF))
		    fprintf(hTrap, " - 16:16  Selector %4.4hX\n", SELECTOROF((PVOID)pDbgBuf->Addr));
		else
		    fputs(" - 32 Bits\n", hTrap);
	    }
	    else
		fputs(" - ?\n", hTrap);
	}
	else {
	    // printf("DosDebug return code = %ld Notification %8.8lX\n", rc,pDbgBuf->Cmd);
	    // printf("Value                = %8.8lX %ld\n",pDbgBuf->Value,pDbgBuf->Value);
	    break;
	}
    } /* for objects */
    fputc('\n', hTrap);

} // GetObjects

#else /* ifndef USE_DOSDEBUG */

//== GetObjects() List objects for module ==

static VOID GetObjects(tDbgBuf *pDbgBuf, HMODULE hMte, PSZ pName);

//== ListModules() List modules for executable  ==

static VOID ListModules()
{
    APIRET rc;
    APIRET16 rc16;

    PVOID pvBaseAddress;
    ULONG ulRegionSize;
    ULONG ulAllocationFlags;
    HMODULE hLastModule;
    // CHAR szModName[CCHMAXPATH];	// 10 Oct 07 SHL
    // ULONG ulSize;			// 10 Oct 07 SHL

    hLastModule = 0;
    pvBaseAddress = (PVOID)0x10000;
    ulRegionSize = 0x3FFFFFFF;
    fputs("\nÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿\n", hTrap);
    fputs("³ List of currently accessed modules (DLLs) object addresses              ³", hTrap);
    rc = DosQueryMem(pvBaseAddress, &ulRegionSize, &ulAllocationFlags);
    while (rc == NO_ERROR) {
	if (ulAllocationFlags & PAG_EXECUTE &&
	    ulAllocationFlags & PAG_BASE)
	{
	    rc = DosQueryModFromEIP(&hMod, &ulObjNum, CCHMAXPATH,
				    szModName, &ulOffset, (ULONG)pvBaseAddress);
	    if (rc == NO_ERROR) {
		if (hMod != hLastModule) {
		    rc = DosQueryModuleName(hMod, CCHMAXPATH, szFileName);
		    sprintf(szBuffer, "%lX (%lu)", hMod, hMod);
		    fputs("\nÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´\n", hTrap);
		    fprintf(hTrap, "³ Module %-45.45s Handle %-11.11s ³\n",
			    rc == NO_ERROR ? szFileName : szModName,
			    szBuffer);
		    fputs("³ Object Number    Address    Length     Flags       Type                 ³", hTrap);
		    hLastModule = hMod;
		}

		if (ulOffset == 0xffffffff) {
		    fprintf(hTrap, "\n³ %4.4X:%8.8X    %8.8lX   %8.8lX   %8.8lX ",
			    ulObjNum & 0xffff, ulOffset, pvBaseAddress, ulRegionSize, ulAllocationFlags);
		}
		else {
		    fprintf(hTrap, "\n³       % 6.6d    %8.8lX   %8.8lX   %8.8lX ",
			    ulObjNum, pvBaseAddress, ulRegionSize, ulAllocationFlags);
		}

		// fixme to know of DOS16SIZESEG really needed these days
		// fixme to know if 16/32 bit
		rc16 = DOS16SIZESEG(SELECTOROF(pvBaseAddress), &ulSize);
		if (rc16 == NO_ERROR && ulRegionSize < 0x10000)
		    fprintf(hTrap, " - 16:16  Selector %4.4hX ³", SELECTOROF((PVOID)pvBaseAddress));
		else
		    fputs(" - 32 Bits              ³", hTrap);
	    }
	}

	if (ulAllocationFlags & PAG_FREE)
	    ulRegionSize = 0x10000;

	ulRegionSize += 0x0FFF;
	ulRegionSize &= 0xFFFFF000;		// Round to 64KB
	pvBaseAddress = (PCHAR)pvBaseAddress + ulRegionSize;
	ulRegionSize = ((PCHAR)0x3FFFFFFF) - (PCHAR)pvBaseAddress;

	// Find next valid region
	rc = DosQueryMem(pvBaseAddress, &ulRegionSize, &ulAllocationFlags);
	while (rc == ERROR_INVALID_ADDRESS ||
	       rc == ERROR_NO_OBJECT)
	{
	    pvBaseAddress = (PCHAR)pvBaseAddress + 0x10000;
	    if (pvBaseAddress > (PVOID)0x3FFFFFFF)
		break;

	    ulRegionSize = (PCHAR)0x3FFFFFFF - (PCHAR)pvBaseAddress;
	    rc = DosQueryMem(pvBaseAddress, &ulRegionSize, &ulAllocationFlags);
	} /* while */

	if (pvBaseAddress > (PVOID)0x3FFFFFFF)
	    break;			// Stop at 1GB

    } /* while OK */

    fputs("\nÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ\n", hTrap);
} // ListModules

#endif /* ifndef USE_DOSDEBUG */

//=== PrintMemoryAttributes() Print memory attributes ===

static VOID PrintMemoryAttributes(PVOID pvAddress, PSZ pszDesc)
{
    APIRET rc;
    // ULONG ulSize = 1;		// 10 Oct 07 SHL
    // ULONG ulFlags;			// 10 Oct 07 SHL
    // ULONG ulAttr;			// 10 Oct 07 SHL

    ulSize = 1;
    rc = DosQueryMem(pvAddress, &ulSize, &ulAttr);
    if (rc != NO_ERROR)
	fprintf(hTrap, "³ %3.3s does not point to valid memory ³\n", pszDesc);
    else {
	if (ulAttr & PAG_FREE)
	    fprintf(hTrap, "³ %3.3s points to unallocated memory   ³\n", pszDesc);
	else {
	    if (~ulAttr & PAG_COMMIT)
		fprintf(hTrap, "³ %3.3s points to uncommited  memory   ³\n", pszDesc);
	    if (~ulAttr & PAG_WRITE)
		fprintf(hTrap, "³ %3.3s points to unwritable  memory   ³\n", pszDesc);
	    if (~ulAttr & PAG_READ)
		fprintf(hTrap, "³ %3.3s points to unreadable  memory   ³\n", pszDesc);
	}
    }
} // PrintMemoryAttributes

//=== WalkStack() Walk stack and print function addresses and local variables ===

/* Better New WalkStack From John Currier */

static VOID WalkStack(PVOID pvStackBottom, PVOID pvStackTop,
		      ULONG ulEBP, USHORT usSS,
		      ULONG ulEIP, USHORT usCS)
{
    ULONG ul32BitAddr;
    ULONG ulLastEbp;
    APIRET rc;
    // ULONG ulSize;			// 10 Oct 07 SHL
    // ULONG ulAttr;			// 10 Oct 07 SHL
    // HMODULE hMod;			// 10 Oct 07 SHL
    // ULONG ulObjNum;			// 10 Oct 07 SHL
    // ULONG ulOffset;			// 10 Oct 07 SHL
    BOOL isPass1 = TRUE;	// Use passed address 1st time thru

    BOOL is32Bit = usCS == FLATCS;

    // Note: we can't handle stacks bigger than 64K for now...

    fputs("\nCall Stack:\n", hTrap);
    fputs("                                             Source     Line     Nearest\n", hTrap);
    fputs("   EBP      Address Module    Obj:Offset      File      Numbr  Public Symbol\n", hTrap);
    fputs(" ÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄ\n", hTrap);

    for (;;) {

	ulSize = 12;		// sufficient to hold ebp, cs:eip
	if (is32Bit)
	    rc = DosQueryMem((PVOID)(ulEBP), &ulSize, &ulAttr);
	else {
	    ul32BitAddr = (ULONG)(usSS & ~7) << 13 | ulEBP;	// Thunk
	    rc = DosQueryMem((PVOID)(ul32BitAddr), &ulSize, &ulAttr);
	}
	if (rc != NO_ERROR || ~ulAttr & PAG_COMMIT || ulSize < 12) {
	    if (is32Bit)
		fprintf(hTrap, "Invalid EBP %8.8X\n", ulEBP);
	    else
		fprintf(hTrap, "Invalid SS:BP: %4.4X:%4.4X\n", usSS, ulEBP);
	    break;
	}

	// If pass1, use passed initial values else get from stack
	if (!isPass1) {
	    if (is32Bit) {
		ulEIP = *((PULONG)(ulEBP + 4));
		if (ulEIP == FLATDS) {
		    /* If there's a "return address" of FLATDS following
		       EBP on the stack we have to adjust EBP by 44 bytes to get
		       at the real return address.  This has something to do with
		       calling 32-bit code via a 16-bit interface
		       This offset applies to VAC runtime and might vary for others.
		     */
		    ulEBP += 44;
		    ulEIP = *(PULONG)(ulEBP + 4);
		}
	    }
	    else {
		ulEIP = *((PUSHORT)(ul32BitAddr + 2));
		usCS = *(PUSHORT)(ul32BitAddr + 4);
		// If CS is now FLATDS, we are returning to 32 bit code from 16-bit code
		// fixme to check ulEIP == 0x150B?
		if (usCS == FLATDS) {
		    ulEBP = ul32BitAddr + 20;
		    usSS = FLATDS;
		    ulEIP = *(PULONG)(ulEBP + 4);
		    usCS = FLATCS;
		    is32Bit = TRUE;
		}
	    }
	}

	if (!is32Bit) {
	  // if the return address points to the stack then it's really just
	  // a pointer to the return address (UGH!).
	  if (usCS == usSS) {
	      ul32BitAddr = (ULONG)(usSS & ~7) << 13 | ulEIP;	// Thunk
	      ulEIP = *(PUSHORT)(ul32BitAddr);
	      usCS = *(PUSHORT)(ul32BitAddr + 2);
	  }

	  if (ulEIP == 0 && *(PUSHORT)ulEBP == 0) {
	      // End of the stack so these are both shifted by 2 bytes:
	      ul32BitAddr = (ULONG)(usSS & ~7) << 13 | ulEBP;	// Thunk
	      ulEIP = *(PUSHORT)(ul32BitAddr + 4);
	      usCS = *(PUSHORT)(ul32BitAddr + 6);
	  }
	}

	// For far calls in 16-bit programs have on the stack:
	//   BP:IP:CS
	//   where CS may be thunked
	//
	//     in byte order               swapped
	//    BP        IP   CS          BP   CS   IP
	//   4677      53B5 F7D0        7746 D0F7 B553
	//
	// for near calls 32bit programs have:
	//   EBP:EIP
	// and you'd have something like this (with SP added) (not
	// accurate values)
	//
	//       in byte order           swapped
	//      EBP       EIP         EBP       EIP
	//   4677 2900 53B5 F7D0   0029 7746 D0F7 B553
	//
	// So the basic difference is that 32bit programs have a 32bit
	// EBP and we can attempt to determine whether we have a 32bit
	// EBP by checking to see if its 'selector' is the same as SP.
	// Note that this technique limits us to checking stacks < 64K.
	//
	// Soooo, if IP (which maps into the same USHORT as the swapped
	// stack page in EBP) doesn't point to the stack (i.e. it could
	// be a 16bit IP) then see if CS is valid (as is or thunked).
	//
	// Note that there's the possibility of a 16bit return address
	// that has an offset that's the same as SP so we'll think it's
	// a 32bit return address and won't be able to successfully resolve
	// its details.

	if (!is32Bit ) {
	    if (ulEIP != usSS) {
		if (DOS16SIZESEG((USHORT)usCS, &ulSize) == NO_ERROR)
		    ; // ulRetAddr = MAKEULONG(ulEIP, usCS);	// 27 Jul 07 SHL
		else if (DOS16SIZESEG((usCS << 3) | 7, &ulSize) == NO_ERROR) {
		    // usCS = (usCS << 3) | 7;
		    // ulRetAddr = (ULONG)(USHORT * _Seg16)MAKEULONG(ulEIP, usCS);
		}
		else {
		    is32Bit = TRUE;
		    // fixme to be sure this is right
		    ulEIP = (ULONG)usCS << 16 | ulEIP;
		    usCS = FLATCS;		// fixme?
		}
	    }
	    else {
		// fixme to get adjusted EIP?
		is32Bit = TRUE;
		usCS = FLATCS;		// fixme?
	    }
	}

	if (isPass1)
	    fputs(" Trap  ->", hTrap);
	else
	    fprintf(hTrap, " %8.8X", ulEBP);

	if (is32Bit)
	    fprintf(hTrap, "  %8.8X", ulEIP);
	else
	    fprintf(hTrap, " %04.04X:%04.04X", usCS, ulEIP);

	if (aulOSVersion[0] >= 20 && aulOSVersion[1] >= 10) {
	    // Make a 'tick' sound to let the user know we're still alive
	    DosBeep(2000, 1);

	    ulSize = 10;		/* Inserted by Kim Rasmussen 26/06 1996 to avoid error 87 when Size is 0 */

	    if (is32Bit)
		ul32BitAddr = ulEIP;
	    else
		ul32BitAddr = (ULONG)(usCS & ~7) << 13 | ulEIP;		// Thunk

	    rc = DosQueryMem((PVOID)ul32BitAddr, &ulSize, &ulAttr);
	    if (rc != NO_ERROR || ~ulAttr & PAG_COMMIT) {
		fprintf(hTrap, " Invalid address: %8.8X\n", ul32BitAddr);
		break;			/* avoid infinite loops */
	    }
	    else {
		// CHAR szModName[CCHMAXPATH];	// 10 Oct 07 SHL

		rc = DosQueryModFromEIP(&hMod, &ulObjNum, sizeof(szModName),
					szModName, &ulOffset, (ULONG)ul32BitAddr);
		if (rc == NO_ERROR && ulObjNum != -1) {

		    fprintf(hTrap, " %-8.8s %04X:%08X", szModName, ulObjNum + 1, ulOffset);

		    rc = DosQueryModuleName(hMod, sizeof(szFileName), szFileName);

		    if (rc == NO_ERROR) {
			// Try for line number info from debug data
			rc = PrintLineNum(szFileName, ulObjNum, ulOffset);
			/* if no debug data try with symbol files */
			if (rc != NO_ERROR && strlen(szFileName) > 3) {
			    strcpy(szFileName + strlen(szFileName) - 3, "SYM");
			    PrintSymbolFromSymFile(szFileName, ulObjNum, ulOffset);
			}
		    }
		}
		else
		    fputs("  *Unknown*", hTrap);
	    } // if valid address
	} // if >= v2.1

	fputc('\n', hTrap);

	if (is32Bit) {
	    /* If EBP points to the FLATDS rather than something that looks like an
	       pointer, we are probably looking at a thunk sequence
	       For VAC this is 0x44 bytes in size
	       19 Jul 07 SHL
	    */

	    if (*(PULONG)ulEBP == FLATDS)
		ulEBP += 0x44;
	    if (*(PULONG)ulEBP == 0) {
		fputs("End of Call Stack\n", hTrap);
		break;
	    }
	}
	else {
	    ul32BitAddr = (ULONG)(usSS & ~7) << 13 | ulEBP;	// Thunk
	    ulEBP = *(PUSHORT)ul32BitAddr;
	    // 0x0000 0xFFFF fixme?
	    if (ulEBP == 0 && *(PUSHORT)(ul32BitAddr + 2) == 0) {
		fputs("End of Call Stack\n", hTrap);
		break;
	    }
	}

	if (isPass1)
	    isPass1 = FALSE;
	else {
	    ulLastEbp = ulEBP;

	    /* Inserted by Kim Rasmussen 26/06 1996 to allow big stacks */
	    if (is32Bit)
		ulEBP = *(PULONG)ulLastEbp;
	    else
		ulEBP = MAKEULONG(ulEBP, usSS);

	    if (is32Bit)
		PrintLocalVariables(ulEBP);

	    if (ulEBP < ulLastEbp) {
		fputs("Lost Stack chain - new EBP below previous\n", hTrap);
		break;
	    }
	}

	ulSize = 4;
	if (is32Bit)
	    rc = DosQueryMem((PVOID)ulEBP, &ulSize, &ulAttr);
	else {
	    ul32BitAddr = (ULONG)(usSS & ~7) << 13 | ulEBP;	// Thunk
	    rc = DosQueryMem((PVOID)ul32BitAddr, &ulSize, &ulAttr);
	}
	if (rc != NO_ERROR || ulSize < 4) {
	    if (is32Bit)
		fprintf(hTrap, "Lost Stack chain - invalid EBP %8.8X\n", ulEBP);
	    else
		fprintf(hTrap, "Lost Stack chain - invalid SS:BP %4.4X:%4.4X\n", usSS, ulEBP);
	    break;
	}

    } // forever

} // WalkStack

//=== PrintSymbolFromSymFile() Lookup symbol in .sym file ===

// #define DBGLRG 1			// Enable to generate debug output

static VOID PrintSymbolFromSymFile(CHAR *pszSymFileName, ULONG ulObjNum, ULONG ulOffset)
{
    // Avoid using stack space
    static FILE *fpSymFile;
    static MAPDEF MapDef;
    static SEGDEF SegDef;
    static SEGDEF *pSegDef;
    static SYMDEF32 SymDef32;
    static SYMDEF16 SymDef16;
    // static CHAR szBuffer[256];	// 10 Oct 07 SHL
    static USHORT usSegNum;
    static USHORT usSymNum;
    static ULONG  ulLastSymVal;
    static ULONG ulSegOffset;
    static ULONG ulNextSegOffset;	// 22 May 08 Large file support
    static USHORT usSymOffset;
    static ULONG ulSymOffsetAdjust;	// Large file support
    static USHORT usLastSymOffset;	// Large file support
    static ULONG ulSymPtrOffset;
    static ULONG ulSymPtrAdjust;	// Large file support

    // 12 Dec 07 SHL fixme debug
    // static ULONG ulDebug1;
    // static ULONG ulDebug2;

    fpSymFile = fopen(pszSymFileName, "rb");
    if (fpSymFile == NULL) {
	// Try current directory too
	psz = strrchr(pszSymFileName, '\\');
	if (psz)
	    fpSymFile = fopen(psz + 1, "rb");
    }
    if (fpSymFile == NULL) {
	// fixme to report if not file not found
	/* fprintf(hTrap, "Can not open symbol file %s (%u)\n",pszSymFileName, errno); */
	fputc('\n', hTrap);
	return;
    }
    if (fread(&MapDef, sizeof(MAPDEF), 1, fpSymFile) != 1) {
	fputs(" Can not read MapDef ",hTrap);
	return;
    }

    ulSegOffset = SEGDEFOFFSET(MapDef);

    for (usSegNum = 0; usSegNum < MapDef.cSegs; usSegNum++) {
#	ifdef DBGLRG
	fprintf(hTrap, "\n  * ulSegOffset 0x%08X Segment #%d\n",ulSegOffset,usSegNum+1);
#	endif

	if (fseek(fpSymFile, ulSegOffset, SEEK_SET)) {
	    fprintf(hTrap, " Can not seek to SegfDef at %x ", ulSegOffset);
	    return;
	}

	if (fread(&SegDef, sizeof(SEGDEF), 1, fpSymFile) != 1) {
	    fprintf(hTrap, " Can not read to SegfDef at %x ", ulSegOffset);
	    return;
	}

	if (usSegNum == ulObjNum) {

	    /* 23 May 08 SHL Add oversized .sym file support
	       Symbol table format uses 16-bit offsets to point at the symbol
	       pointer table and to point at SymDef entries.  This breaks if there
	       are more than approx 64KiB of SymDefs.  To workaround this,
	       we assume that the symbol pointer table ends at the next SegDef
	       or at the end of file.  We then use the difference between the
	       calculated offset of the end of the pointer table and the calculated
	       offset to the next SegDef to calculate an adjusting offset.
	       This offset is applied to symbol pointer table lookups.
	       We also assume that the SymDef offsets in the symbol pointer table
	       are monotonic and detect 64KiB boundary crossings to calculate an
	       adjusting offset.  This offset is applied to SymDef entry indexing.
	    */
	    // Calc location of symbol pointer table based on values
	    ulSymPtrOffset=SYMDEFOFFSET(ulSegOffset,SegDef,SegDef.cSymbols);
	    // Calc location of next segment
	    if (usSegNum + 1 == MapDef.cSegs) {
	       fseek(fpSymFile,0,SEEK_END);
	       ulNextSegOffset = ftell(fpSymFile);
	    }
	    else
	       ulNextSegOffset=NEXTSEGDEFOFFSET(SegDef);
	    // Calc offset error in 64K blocks
	    ulSymPtrAdjust = (ulNextSegOffset - ulSymPtrOffset) / 0x10000;
	    // Calc offset adjust - will be 0 for normal files
	    ulSymPtrAdjust *= 0x10000;

#	    ifdef DBGLRG
	    if (ulSymPtrAdjust)
	       fprintf(hTrap, "  * Adjusting pSymDef by 0x%lx for large file\n",ulSymPtrAdjust);
#	    endif

	    usSymOffset = 0;
	    ulSymOffsetAdjust = 0;

	    // At requested object
	    strcpy(szBuffer, "Start");	// In case no symbol at offset 0
	    ulLastSymVal = 0;

	    for (usSymNum = 0; usSymNum <= SegDef.cSymbols; usSymNum++) {
		ulSymPtrOffset = SYMDEFOFFSET(ulSegOffset, SegDef, usSymNum);
		ulSymPtrOffset += ulSymPtrAdjust;	// 22 May 08 SHL Adjust for large files
#	        ifdef DBGLRG
		fprintf(hTrap, "  * ulSymPtrOffset 0x%08X Sym #%d",ulSymPtrOffset,usSymNum+1);
#	        endif
		if (fseek(fpSymFile, ulSymPtrOffset, SEEK_SET)) {
		  fprintf(hTrap, " Can not seek to SymDef offset at %x ", ulSymPtrOffset);
		  return;
		}
		usLastSymOffset = usSymOffset;
		if (fread(&usSymOffset, sizeof(USHORT), 1, fpSymFile) != 1) {
		    fprintf(hTrap, " Can not read SymDef offset at %x ", ulSymPtrOffset);
		    return;
		}
#	        ifdef DBGLRG
		fprintf(hTrap, " usSymOffset 0x%X",usSymOffset);
#	        endif
		// If symbol entries crossed 64K boundary, bump adjusting offset
		if (usSymOffset < usLastSymOffset) {
		    ulSymOffsetAdjust += 0x10000;
#		    ifdef DBGLRG
		    fprintf(hTrap, "\n  * Adjusting usSymOffset by 0x%lx for large file\n    ",ulSymOffsetAdjust);
#		    endif
		}
		ul = usSymOffset+ulSegOffset+ulSymOffsetAdjust;
#		ifdef DBGLRG
		fprintf(hTrap, " SymDef at 0x%08X\n",ul);
#		endif
		if (fseek(fpSymFile, ul, SEEK_SET)) {
		    fprintf(hTrap, " Can not seek to SymDef at %x ", ul);
		    return;
		}
		if (SegDef.bFlags & 0x01) {
		    // 32-bit segment
		    if (fread(&SymDef32, sizeof(SYMDEF32), 1, fpSymFile) != 1) {
			fprintf(hTrap, " Can not read to SymDef32 at %x ", ul);
			return;
		    }
		    // If requested offset greater than previous symbol offset and
		    // requested offset less than current symbol offset then
		    // time to display
		    ul = ulOffset >= ulLastSymVal && ulOffset < SymDef32.wSymVal;
		    if (ul) {
#		        ifdef DBGLRG
			fputs("    ->",hTrap);
#		        endif
			// Time to display
			// 12 Dec 07 SHL fixme debug
			// ulDebug1 = ulLastSymVal;
			// ulDebug2 = SymDef32.wSymVal;
			if (ulOffset == ulLastSymVal) {
			    // 12 Dec 07 SHL fixme debug
			    // fprintf(hTrap, " %s (%X %X %X)", szBuffer, ulOffset, ulDebug1, ulDebug2);
			    fprintf(hTrap, " %s", szBuffer);
			    break;	// Done
			}
			else {
			    fprintf(hTrap, " between %s + %X ", szBuffer, ulOffset - ulLastSymVal);
			}
		    }

		    // Remeber symbol and offset
		    ulLastSymVal = SymDef32.wSymVal;
		    szBuffer[0] = SymDef32.achSymName[0];
		    if (fread(&szBuffer[1], 1, SymDef32.cbSymName, fpSymFile) != SymDef32.cbSymName) {
		      fprintf(hTrap, " Can not read to SymDef32 symbol at %x ", ul);
		      return;
		    }
		    szBuffer[SymDef32.cbSymName] = 0;

		    // If requested offset between symbols or at symbol time to display
		    if (ul) {
			// Time to display
			// 12 Dec 07 SHL fixme debug
			// fprintf(hTrap, "and %s - %X (%X %X %X)", szBuffer, ulLastSymVal - ulOffset, ulOffset, ulDebug1, ulDebug2);
			fprintf(hTrap, "and %s - %X", szBuffer, ulLastSymVal - ulOffset);
			break;		// Done
		    }
		    else if (usSymNum + 1 == SegDef.cSymbols) {
			ul = ulOffset >= ulLastSymVal && *szBuffer;
			if (ul) {
			    if (ulOffset == ulLastSymVal) {
				// 12 Dec 07 SHL fixme debug
				// fprintf(hTrap, " %s", szBuffer);
				fprintf(hTrap, " %s (%X)", szBuffer, ulOffset);
			    }
			    else {
				// 12 Dec 07 SHL fixme debug
				// fprintf(hTrap, " near %s + %X (%X)", szBuffer, ulOffset - ulLastSymVal, ulOffset);
				fprintf(hTrap, " near %s + %X ", szBuffer, ulOffset - ulLastSymVal);
			    }
			}
		    }
		} // if 32-bit
		else {
		    // 16-bit segment
		    if (fread(&SymDef16, sizeof(SYMDEF16), 1, fpSymFile) != 1) {
		      fprintf(hTrap, " Can not read to SymDef16 at %x ", ul);
		      return;
		    }
		    // 11 Oct 07 SHL fixme to be like 32 bit above
		    if (SymDef16.wSymVal > ulOffset) {
			if (ulOffset == ulLastSymVal) {
			    fprintf(hTrap, " %s", szBuffer);
			    break;	// Done
			}
			else
			    fprintf(hTrap, " between %s + %X ", szBuffer, ulOffset - ulLastSymVal);
		    }

		    ulLastSymVal = SymDef16.wSymVal;
		    szBuffer[0] = SymDef16.achSymName[0];
		    if (fread(&szBuffer[1], 1, SymDef16.cbSymName, fpSymFile) != SymDef16.cbSymName) {
		      fprintf(hTrap, " Can not read to SymDef16 sym at %x ", ul);
		      return;
		    }
		    szBuffer[SymDef16.cbSymName] = 0;
		    if (SymDef16.wSymVal > ulOffset) {
			fprintf(hTrap, "and %s - %X", szBuffer, ulLastSymVal - ulOffset);
			break;		// Done
		    }
		} // if 16-bit
	    } // for symbols
	    break; // Done with symbol
	} // if this segment
	ulSegOffset = NEXTSEGDEFOFFSET(SegDef);
    } /* for segments */
    fclose(fpSymFile);
    fputc('\n', hTrap);

} // PrintSymbolFromSymFile

static VOID WakeThreads(VOID);

//== ForceExit() Force application exit by forced trap - fixme ==

VOID APIENTRY ForceExit()
{
    EXCEPTIONREPORTRECORD except;
    PCHAR Trap = NULL;

    fInForceExit = TRUE;
    fclose(stderr);			/* I don't want error messages since all is intentional */
    DosError(FERR_DISABLEEXCEPTION | FERR_DISABLEHARDERR);
    DosEnterCritSec();
    WakeThreads();
    printf("Exiting by exception\n");
    DosSetPriority(PRTYS_THREAD, PRTYC_FOREGROUNDSERVER, PRTYD_MAXIMUM, 0);
    DosExitCritSec();
    *Trap = 0;			// Say bye bye

} // ForceExit

//== WakeThreads() Wake all waiting threads fixme ==

static VOID WakeThreads()
{
    APIRET rc;
    APIRET16 rc16;
    QSPREC *pProc;			// 06 Feb 08 SHL
    QSTREC *pThread;			// 06 Feb 08 SHL
    ULONG ListedThreads = 0;
    PTIB ptib;
    PPIB ppib;

    DosGetInfoBlocks(&ptib, &ppib);

    rc16 = DOS16ALLOCSEG(0xFFFF, &Selector, 0);
    if (rc16 != NO_ERROR)
	printf("DosAllocSeg Failed %hd\n", rc16);
    else {
	ULONG *pBuf;
	pBuf = MAKEP(Selector, 0);
	rc16 = DOSQPROCSTATUS(pBuf, 0xFFFF);
	if (rc16 != NO_ERROR)
	    printf("DosQProcStatus Failed %hd\n", rc16);
	else {
	    pRec = (QSPTRREC *) pBuf;	// 06 Feb 08 SHL
	    pProc = (QSPREC *) (pRec->pProcRec);	// 06 Feb 08 SHL
	    ListedThreads = 0;
	    while (ListedThreads < pRec->pGlobalRec->cThrds) {
		INT Tid;

		if (pProc->pThrdRec == NULL)
		    break;
		ListedThreads += pProc->cTCB;
		if (ppib->pib_ulpid == pProc->pid) {
		    for (Tid = 0; Tid < pProc->cTCB; Tid++) {
			pThread = pProc->pThrdRec + Tid;
			// if fixme?
			if (pThread->state == 0x09) {
			    printf("Resuming Thread %d\n", (TID) pThread->tid);
			    DosResumeThread((TID) pThread->tid);
			}
		    }			/* endfor */
		    break;
		}			/* endif  */
		// 06 Feb 08 SHL
		pProc = (QSPREC *)(((PUCHAR)pProc) + sizeof(QSPREC) +
				   sizeof(USHORT) *
				     (pProc->c16Sem + pProc->cLib + pProc->cShrMem) +
				   pProc->cTCB * sizeof(QSTREC));

	    } /* while */
	}
    }

} // WakeThreads

//===========================
//== Debug info extractors ==
//===========================

// 24 May 08 SHL fixme to be in debuginfo.h?
// 24 May 08 SHL fixme to use omf.h everwhere

#ifndef DWORD
#define DWORD LONG
#endif

#ifndef WORD
#define WORD  SHORT
#endif

// fixme to use omf.h definitions
// see ow\bld\watcom\h\hll.h

#pragma pack(1)

/* Last 8 bytes of when OMF style debugging info is present
 * Used for Codeview and VAC HLL and BC OA debug data
 * signature is FB for BC OA debug
 */

#if 0 // 24 May 08 SHL now using omf.h
struct {
    USHORT signature;	/* signature ('NB' or 'FB') */
    USHORT version;	/* version '00', '01' '04' ... */
    ULONG dfaBase;	/* size of codeview info */
} eodbug;
#endif

struct debug_tail_rec debug_tail;

#if 0 // 22 May 08 SHL use omf.h
struct {
    USHORT signature;	/* signature ('NB' or 'FB') */
    USHORT version;	/* version '00', '01' '04' ... */
    ULONG lfoDir;	/* offset to directory entries from debug_head_rec */
} debug_head;
#endif

struct debug_head_rec debug_head;

/* HLL debug directory info. */
typedef struct {
    USHORT cbDirHeader;
    USHORT cbDirEntry;
    ULONG cDir;
} hll_dirinfo;

/* CV3 debug directory info. */
typedef struct {
    USHORT cDir;
} cv3_dirinfo;

// Codeview 16
struct ssDir16
{
    USHORT sst;		/* SubSection Type */
    USHORT modindex;	/* Module index number */
    ULONG lfoStart;	/* Start of section */
    USHORT cb;		/* Size of section */
};

struct ssDir32
{
    USHORT sst;		/* SubSection Type */
    USHORT modindex;	/* Module index number */
    ULONG lfoStart;	/* Start of section */
    ULONG cb;		/* Size of section */
};

struct ssModule
{
    USHORT csBase;	/* code segment base */
    USHORT csOff;	/* code segment offset */
    USHORT csLen;	/* code segment length */
    USHORT ovrNum;	/* overlay number */
    USHORT indxSS;	/* Index into sstLib or 0 */
    USHORT reserved;
    CHAR csize;		/* size of prefix string */
} ssmod;

struct ssModule32
{
    USHORT csBase;	/* code segment base */
    ULONG csOff;	/* code segment offset */
    ULONG csLen;	/* code segment length */
    ULONG ovrNum;	/* overlay number */
    USHORT indxSS;	/* Index into sstLib or 0 */
    ULONG reserved;
    CHAR csize;			/* size of prefix string */
} ssmod32;

struct ssPublic
{
    USHORT offset;
    USHORT segment;
    USHORT type;
    CHAR csize;
} sspub;

struct ssPublic32
{
    ULONG offset;
    USHORT segment;
    USHORT type;
    CHAR csize;
} sspub32;

typedef struct _SSLINEENTRY32
{
    USHORT LineNum;
    USHORT FileNum;
    ULONG ulOffset;
} SSLINEENTRY32;

// 24 May 08 SHL fixme to use linfirst_rec from omh.h
typedef struct _FIRSTLINEENTRY32
{
    USHORT LineNum;
    UCHAR entry_type;				// See omf.h
    UCHAR reserved;
    USHORT numlines;
    USHORT usSegNum;
} FIRSTLINEENTRY32;

typedef struct _SSFILENUM32
{
    ULONG first_displayable;	/* Not used */
    ULONG number_displayable;	/* Not used */
    ULONG file_count;	/* number of source files */
} SSFILENUM32;

struct DbugRec
{				/* debug info struct ure used in linked * list */
    struct DbugRec far *pnext;	/* next node *//* 013 */
    char far *SourceFile;	/* source file name *013 */
    USHORT TypeOfProgram;	/* dll or exe *014* */
    USHORT LineNumber;	/* line number in source file */
    USHORT OffSet;	/* offset into loaded module */
    USHORT Selector;	/* code segment 014 */
    USHORT OpCode;	/* Opcode replaced with BreakPt */
    ULONG Count;	/* count over Break Point */
};

typedef struct DbugRec DBUG, far * DBUGPTR;	/* 013 */

#pragma pack()

// keep largish strings static to limit stack usage

static CHAR szNearestFile[128];		// For current cs:eip
static CHAR szNearestLine[128];
static CHAR szNearestPubDesc[128];
static struct new_seg *pNewSeg;
static ULONG lfaBase;

/* ------------------------------------------------------------------ */

//=== PrintLineNum() Print line number info from embedded debug data or DBG file ===

static APIRET PrintLineNum(CHAR *pszFileName, ULONG ulObjNum, ULONG ulOffset)
{
    APIRET rc = NO_ERROR;
    static INT fh;
    static struct exe_hdr old_hdr;
    static struct new_exe new_hdr;
    static PSZ pszFlpFmt = " %s%s %s\n";

    *szNearestPubDesc, 0;
    *szNearestLine, 0;
    *szNearestFile = 0;
    fh = sopen(pszFileName, O_RDONLY | O_BINARY, SH_DENYNO);
    if (fh == -1) {
	fprintf(hTrap, "Can not open %s (%d)\n", pszFileName, errno);
	rc = 1;
    }
    else {
	/* Read old Exe header */
	if (read(fh, &old_hdr, 64) == -1L) {
	    fprintf(hTrap, "Can not read old exe header %d\n", errno);
	    close(fh);
	    return 2;
	}
	if (NE_MAGIC(*(struct new_exe*)&old_hdr) == E32MAGIC)
	    // 23 May 08 SHL Support stripped LX exes
	    memcpy(&new_hdr, &old_hdr, 64);	// MZ header stripped
	else {
	    /* Seek to new Exe header */
	    if (lseek(fh, (LONG)E_LFANEW(old_hdr), SEEK_SET) == -1L) {
		fprintf(hTrap, "Can not seek to new exe header %d\n", errno);
		close(fh);
		return 3;
	    }
	    if (read(fh, (PVOID )&new_hdr, 64) == -1L) {
		fprintf(hTrap, "Can not read new exe header %d\n", errno);
		close(fh);
		return 4;
	    }
	}
	/* Check EXE signature (LX) */
	if (NE_MAGIC(new_hdr) == E32MAGIC) {
	    /* Flat 32 executable (LX) */
	    rc = Read32PmDebug(fh, ulObjNum + 1, ulOffset, pszFileName);
	    close(fh);
	    if (rc == NO_ERROR)
		fprintf(hTrap, pszFlpFmt, szNearestFile, szNearestLine, szNearestPubDesc);
	    else {
		/* If debug data not in executable, try for DBG file */
		strcpy(pszFileName + strlen(pszFileName) - 3, "DBG");
		fh = sopen(pszFileName, O_RDONLY | O_BINARY, SH_DENYNO);
		if (fh != -1) {
		    rc = Read32PmDebug(fh, ulObjNum + 1, ulOffset, pszFileName);
		    if (rc == NO_ERROR)
			fprintf(hTrap, pszFlpFmt, szNearestFile, szNearestLine, szNearestPubDesc);
		    close(fh);
		}
	    }
	}
	else if (NE_MAGIC(new_hdr) == NEMAGIC) {
#	    ifdef WANT_CODEVIEW
	    /* 16:16 executable (NE) */
	    if ((pNewSeg = (struct new_seg *)calloc(NE_CSEG(new_hdr), sizeof(struct new_seg))) == NULL)
	    {
		fputs("Out of memory!", hTrap);
		close(fh);
		return -1;
	    }
	    if (lseek(fh, E_LFANEW(old_hdr) + NE_SEGTAB(new_hdr), SEEK_SET) == -1L) {
		fprintf(hTrap, "Can not seek to segment table in %s (%d)\n", pszFileName, errno);
		free(pNewSeg);
		close(fh);
		return 9;
	    }

	    if (read(fh, pNewSeg, NE_CSEG(new_hdr) * sizeof(struct new_seg)) == -1)
	    {
		fprintf(hTrap, "Can not read segment table from %s (%d)\n", pszFileName, errno);
		free(pNewSeg);
		close(fh);
		return 10;
	    }
	    rc = Read16CodeView(fh, ulObjNum + 1, ulOffset, pszFileName);
	    if (rc == NO_ERROR)
		fprintf(hTrap, pszFlpFmt, szNearestFile, szNearestLine, szNearestPubDesc);
	    free(pNewSeg);
	    close(fh);

	    /* If debug data executable, try DBG file */
	    if (rc != NO_ERROR) {
		strcpy(pszFileName + strlen(pszFileName) - 3, "DBG");	/* Build DBG File name */
		fh = sopen(pszFileName, O_RDONLY | O_BINARY, SH_DENYNO);
		if (fh != -1) {
		    rc = Read16CodeView(fh, ulObjNum + 1, ulOffset, pszFileName);
		    if (rc == NO_ERROR)
			fprintf(hTrap, pszFlpFmt, szNearestFile, szNearestLine, szNearestPubDesc);
		    close(fh);
		}
	    }
#	    endif // WANT_CODEVIEW
	}
	else {
	    /* Unknown executable */
	    fputs("Could not find exe signature", hTrap);
	    close(fh);
	    rc = 11;
	}
    }

    return rc;

} // PrintLineNum

static CHAR szFuncName[128];
static ULONG ulNearestPubOffset;

#ifdef WANT_CODEVIEW

//== Read16CodeView() Read 16 bit CodeView data for cs:ip, return data in globals ==

static INT Read16CodeView(INT fh, USHORT usSegNum, USHORT usOffset, CHAR *pszFileName)
{
    static USHORT offset;
    static USHORT usNearestPublic;
    static USHORT usNearestLine;
    static USHORT numdir;
    static USHORT namelen;
    static USHORT numlines;
    static USHORT line;
    static USHORT ModIndex;
    static INT nBytesRead;		// fixme to be ULONG?
    static UINT uDirNdx;
    static UINT uLineNdx;
    static struct ssDir16 *pDirTab;

    ModIndex = 0;
    /* Check if CODEVIEW data exists */
    if (lseek(fh, -8L, SEEK_END) == -1) {
	fprintf(hTrap, "Error %u seeking CodeView table in %s\n", errno, pszFileName);
	return 18;
    }
    if (read(fh, &debug_tail, 8) == -1) {
	fprintf(hTrap, "Error %u reading debug info from %s\n", errno, pszFileName);
	return 19;
    }
    if (debug_tail.signature != DBUGSIG) {
	/* fputs("\nNo CodeView information stored.\n",hTrap); */
	return 100;
    }
    if ((lfaBase = lseek(fh, -debug_tail.offset, SEEK_END)) == -1L) {
	fprintf(hTrap, "Error %u seeking codeview data header in %s\n", errno, pszFileName);
	return 20;
    }
    if (read(fh, &debug_head, 8) == -1) {
	fprintf(hTrap, "Error %u reading codeview data header in %s\n", errno, pszFileName);
	return 21;
    }
    if (lseek(fh, debug_head.lfoDir - 8, SEEK_CUR) == -1) {
	fprintf(hTrap, "Error %u seeking dir codeview data in %s\n", errno, pszFileName);
	return 22;
    }
    if (read(fh, &numdir, 2) == -1) {
	fprintf(hTrap, "Error %u reading dir codeview data in %s\n", errno, pszFileName);
	return 23;
    }
    /* Allocate dir table buffer */
    if ((pDirTab = (struct ssDir16 *)calloc(numdir, sizeof(struct ssDir16))) == NULL) {
	fputs("Out of memory!", hTrap);
	return -1;
    }

    /* Read dir table into buffer */
    if (read(fh, pDirTab, numdir * sizeof(struct ssDir16)) == -1) {
	fprintf(hTrap, "Error %u reading codeview DirTab from %s\n", errno, pszFileName);
	free(pDirTab);
	return 24;
    }

    uDirNdx = 0;
    while (uDirNdx < numdir) {
	if (pDirTab[uDirNdx].sst != SSTMODULES) {
	    uDirNdx++;
	    continue;
	}
	usNearestPublic = 0;
	usNearestLine = 0;
	/* point to subsection */
	if (lseek(fh, pDirTab[uDirNdx].lfoStart + lfaBase, SEEK_SET) == -1) {
	    fprintf(hTrap, "Error %u seeking to csBase in %s\n", errno, pszFileName);
	    return 25;
	}
	if (read(fh, &ssmod.csBase, sizeof(ssmod)) == -1) {
	    fprintf(hTrap, "Error %u reading csBase from %s\n", errno, pszFileName);
	    return 26;
	}
	if (read(fh, szModName, (UINT)ssmod.csize) == -1) {
	    fprintf(hTrap, "Error %u reading module name from %s\n", errno, pszFileName);
	    return 27;
	}
	ModIndex = pDirTab[uDirNdx].modindex;
	szModName[ssmod.csize] = 0;
	uDirNdx++;
	while (pDirTab[uDirNdx].modindex == ModIndex && uDirNdx < numdir) {
	    /* point to subsection */
	    if (lseek(fh, pDirTab[uDirNdx].lfoStart + lfaBase, SEEK_SET) == -1) {
		fprintf(hTrap, "Error %u seeking to SST_ section in %s\n", errno, pszFileName);
		return 28;
	    }
	    switch (pDirTab[uDirNdx].sst) {
	    case SSTPUBLICS:
		nBytesRead = 0;
		while (nBytesRead < pDirTab[uDirNdx].cb) {
		    // 10 Oct 07 SHL fixme to check read errors
		    nBytesRead += read(fh, &sspub.offset, sizeof(sspub));
		    nBytesRead += read(fh, szFuncName, (unsigned)sspub.csize);
		    szFuncName[sspub.csize] = 0;
		    if (sspub.segment == usSegNum &&
			sspub.offset >= usNearestPublic &&
			sspub.offset <= usOffset)
		    {
			// Found better match
			usNearestPublic = sspub.offset;
			sprintf(szNearestPubDesc, "%s%s %04hX:%04hX (%s)",
				sspub.type == 1 ? "Abs " : "",
				szFuncName,
				sspub.segment,
				sspub.offset,
				szModName);
		    }
		}
		break;

	    case SSTSRCLINES2:
	    case SSTSRCLINES:
		if (usSegNum != ssmod.csBase)
		    break;
		namelen = 0;
		read(fh, &namelen, 1);
		read(fh, szFuncName, namelen);
		szFuncName[namelen] = '\0';
		/* skip 2 zero bytes */
		if (pDirTab[uDirNdx].sst == SSTSRCLINES2)
		    read(fh, &numlines, 2);
		read(fh, &numlines, 2);
		for (uLineNdx = 0; uLineNdx < numlines; uLineNdx++) {
		    read(fh, &line, 2);
		    read(fh, &offset, 2);
		    if (offset <= usOffset && offset >= usNearestLine) {
			usNearestLine = offset;
			sprintf(szNearestLine, "#%hu", line);
			strcpy(szNearestFile, szFuncName);
#if 0 // debug
			sprintf(szNearestLine,"%04hX:%04hX  line #%hu  (%s) (%s)\n",
				ssmod.csBase,offset,line,szModName,szFuncName);
#endif
		    }
		}
		break;
	    } /* switch */
	    uDirNdx++;
	} /* while modindex */
    } /* while uDirNdx < numdir */
    free(pDirTab);
    return NO_ERROR;

} // Read16CodeView

#endif // WANT_CODEVIEW

//=== IBM HLL debug info (NB04) ===

#define MAX_USERDEFS 150
#define MAX_POINTERS 150

USHORT userdef_count;
USHORT pointer_count;

struct
{
    USHORT idx;
    USHORT type_index;
    BYTE name[33];
} userdefs[MAX_USERDEFS];

struct
{
    USHORT idx;
    USHORT type_index;
    BYTE type_qual;
    BYTE name[33];
} pointers[MAX_POINTERS];

//== Read32PmDebug() Read 32-bit debug info for cs:eip, return data in globals  ==

#define MAX_AUTOVARS	100
struct
{
    BYTE name[128];
    ULONG stack_offset;
    USHORT type_idx;
} autovars[MAX_AUTOVARS];

static ULONG autovar_count = 0;
static ULONG ulSymOffset;
static CHAR szSymFuncName[128];

static INT Read32PmDebug(INT fh, USHORT usSegNum, ULONG ulOffset, CHAR *pszFileName)
{
    UINT CurrSymSeg = 0;
    UINT ulNearestPub = 0;
    UINT NearestFile = 0;
    UINT NearestLine = 0;
    UINT numdir;
    UINT namelen;
    UINT numlines;
    UINT uModIndex = 0;
    INT nBytesRead;
    UINT uDirNdx;
    UINT uNdx;
    SSLINEENTRY32 LineEntry;
    SSFILENUM32 FileInfo;
    FIRSTLINEENTRY32 FirstLine;
    BOOL dump_vars = FALSE;
    USHORT idx;
    BOOL read_types = FALSE;
    ULONG ul;
    ULONG ulFileOffset;

    static struct ssDir32 *pDirTab32;
    static BYTE szName[256];

    /* See if any debug data info */
    if (lseek(fh, -8L, SEEK_END) == -1) {
	fprintf(hTrap, "Can not seek SEEK_END - 8 %s (%d)\n", pszFileName, errno);
	return 18;
    }

    if (read(fh, &debug_tail, 8) == -1) {
	fprintf(hTrap, "Can not read debug sig from %s (%d)\n", pszFileName, errno);
	return 19;
    }
    // 10 Oct 07 SHL fixme?
    if (debug_tail.signature != DBUGSIG) {
	/* fputs("\nNo HLL debug data stored.\n",hTrap); */
	return 100;
    }

    if ((lfaBase = lseek(fh, -debug_tail.offset, SEEK_END)) == -1L) {
	fprintf(hTrap, "Can not seek to debug data tail in %s (%d)\n", pszFileName, errno);
	return 20;
    }

    if (read(fh, &debug_head, 8) == -1) {
	fprintf(hTrap, "Error %u reading HLL debug data header in %s\n", errno, pszFileName);
	return 21;
    }

    if (lseek(fh, debug_head.lfoDir - 8 + 4, SEEK_CUR) == -1) {
	fprintf(hTrap, "Error %u seeking to HLL debug data directory in %s\n", errno, pszFileName);
	return 22;
    }

    if (read(fh, &numdir, 4) == -1) {
	fprintf(hTrap, "Error %u reading HLL debug data directory count in %s\n", errno, pszFileName);
	return 23;
    }

    /* Read dir table into buffer */
    if ((pDirTab32 = (struct ssDir32 *) calloc(numdir, sizeof(struct ssDir32))) == NULL)
    {
	fputs("Out of memory!", hTrap);
	return -1;
    }

    if (read(fh, pDirTab32, numdir * sizeof(struct ssDir32)) == -1) {
	fprintf(hTrap, "Error %u reading HLL debug data directory from %s\n", errno, pszFileName);
	free(pDirTab32);
	return 24;
    }

    for (uDirNdx = 0; uDirNdx < numdir;) {
	// Scan directory for 1st module record
	if (pDirTab32[uDirNdx].sst != SSTMODULES) {
	    uDirNdx++;
	    continue;
	}
	/* point to subsection */
	lseek(fh, pDirTab32[uDirNdx].lfoStart + lfaBase, SEEK_SET);
	read(fh, &ssmod32.csBase, sizeof(ssmod32));	// Read module header

	read(fh, szModName, (unsigned) ssmod32.csize);	// Read name

	uModIndex = pDirTab32[uDirNdx].modindex;
	szModName[ssmod32.csize] = 0;
	uDirNdx++;

	for (; pDirTab32[uDirNdx].modindex == uModIndex && uDirNdx < numdir; uDirNdx++) {
	    /* Position to subsection */
	    if (lseek(fh, pDirTab32[uDirNdx].lfoStart + lfaBase, SEEK_SET) == -1) {
		fprintf(hTrap, "Error %u seeking data in %s\n", errno, pszFileName);
		return 25;
	    }

	    switch (pDirTab32[uDirNdx].sst) {

	    case SSTPUBLICS:
		nBytesRead = 0;
		while (nBytesRead < pDirTab32[uDirNdx].cb) {
		    // 24 May 08 SHL fixme to check read errors
		    nBytesRead += read(fh, &sspub32.offset, sizeof(sspub32));
		    nBytesRead += read(fh, szFuncName, (unsigned) sspub32.csize);
		    szFuncName[sspub32.csize] = 0;
		    if (sspub32.segment == usSegNum &&
			sspub32.offset >= ulNearestPub &&
			sspub32.offset <= ulOffset)
		    {
			// Found closer function
			ulNearestPub = ulNearestPubOffset = sspub32.offset;
			read_types = TRUE;
			sprintf(szNearestPubDesc, "%s%s %04X:%08X (%s)",
				sspub32.type == 1 ? "Abs " : "",
				szFuncName,
				sspub32.segment,
				sspub32.offset,
				szModName);
		    }
		}
		break;

	    case SSTSYMBOLS:
		/* Read symbols, so we can dump the auto variables on the stack */
		if (usSegNum != ssmod32.csBase)
		    break;

		nBytesRead = 0;
		while (nBytesRead < pDirTab32[uDirNdx].cb) {
		    USHORT usLength;
		    BYTE b1;
		    BYTE b2;
		    BYTE bType;
		    static struct symseg_rec symseg;
		    static struct symauto_rec symauto;
		    static struct symproc_rec symproc;

		    /* Read encoded length of this subentry */
		    nBytesRead += read(fh, &b1, 1);
		    if (b1 & 0x80) {
			nBytesRead += read(fh, &b2, 1);
			usLength = ((b1 & 0x7F) << 8) + b2;
		    }
		    else
			usLength = b1;

		    ulFileOffset = tell(fh);

		    nBytesRead += read(fh, &bType, 1);

		    switch (bType) {
		    case SYM_CHANGESEG:
			read(fh, &symseg, sizeof(symseg));
			CurrSymSeg = symseg.seg_no;
			break;

		    case SYM_PROC:
		    case SYM_CPPPROC:
			read(fh, &symproc, sizeof(symproc));
			read(fh, szName, symproc.name_len);
			szName[symproc.name_len] = 0;

			if (CurrSymSeg == usSegNum &&
			    ulOffset >= symproc.offset &&
			    ulOffset < symproc.offset + symproc.length)
			{
			    dump_vars = TRUE;	// Found locals
			    autovar_count = 0;
			    ulSymOffset = symproc.offset;
			    strcpy(szSymFuncName, szName);
			}
			else {
			    dump_vars = FALSE;
			}
			break;

		    case SYM_AUTO:
			if (!dump_vars)
			    break;

			read(fh, &symauto, sizeof(symauto));
			read(fh, szName, symauto.name_len);
			szName[symauto.name_len] = 0;

			if (autovar_count < MAX_AUTOVARS) {
			    strcpy(autovars[autovar_count].name, szName);
			    autovars[autovar_count].stack_offset = symauto.stack_offset;
			    autovars[autovar_count].type_idx = symauto.type_idx;
			    autovar_count++;
			}
			break;

		    } // switch bType

		    nBytesRead += usLength;
		    lseek(fh, ulFileOffset + usLength, SEEK_SET);	// Position to next symbol record

		}
		break;			// SSTSYMBOLS

	    case SSTTYPES:
		// if (uModIndex != usSegNum)

		if (!read_types)
		    break;

		nBytesRead = 0;
		idx = 0x200;
		userdef_count = 0;
		pointer_count = 0;
		while (nBytesRead < pDirTab32[uDirNdx].cb) {
		    static struct type_rec type;
		    static struct type_userdefrec udef;
		    static struct type_pointerrec point;

		    /* Remember current file offset */
		    ulFileOffset = tell(fh);

		    /* Read the length of this subentry */
		    read(fh, &type, sizeof(type));
		    nBytesRead += sizeof(type);

		    switch (type.type) {
		    case TYPE_USERDEF:
			if (userdef_count > MAX_USERDEFS)
			    break;

			read(fh, &udef, sizeof(udef));
			read(fh, szName, udef.name_len);
			szName[udef.name_len] = 0;

			// Insert userdef in table
			userdefs[userdef_count].idx = idx;
			userdefs[userdef_count].type_index = udef.type_index;
			memcpy(userdefs[userdef_count].name, szName, min(udef.name_len + 1, 32));
			userdefs[userdef_count].name[32] = 0;
			userdef_count++;
			break;

		    case TYPE_POINTER:
			if (pointer_count > MAX_POINTERS)
			    break;

			read(fh, &point, sizeof(point));
			read(fh, szName, point.name_len);
			szName[point.name_len] = 0;

			// Insert userdef in table
			pointers[pointer_count].idx = idx;
			pointers[pointer_count].type_index = point.type_index;
			memcpy(pointers[pointer_count].name, szName, min(point.name_len + 1, 32));
			pointers[pointer_count].name[32] = 0;
			pointers[pointer_count].type_qual = type.type_qual;
			pointer_count++;
			break;
		    } // switch type.type

		    ++idx;

		    nBytesRead += type.length;

		    lseek(fh, ulFileOffset + type.length + 2, SEEK_SET);
		}
		break;			// SSTTYPES

	    case SSTSRCLINES32:
		if (usSegNum != ssmod32.csBase)
		    break;

		/* find first type 0 line number record
		 * skip leading type 3 pszFileName list records
		 */
		ulFileOffset = 0;
		do {
		    read(fh, &FirstLine, sizeof(FirstLine));

		    if (FirstLine.LineNum != 0) {
			fputs("Missing Line table information\n", hTrap);
			FirstLine.numlines = 0;
			break;
		    }
		    /* If type 0..3, read rest of header
		     * Type 4 omits length/seg_address field
		     */
		    if (FirstLine.entry_type < 4) {
			read(fh, &ul, 4);
			// If type 3, remember start of file names table and position after
			if (FirstLine.entry_type == 3) {
			    if (!ulFileOffset)
				ulFileOffset = tell(fh);
			    lseek(fh, ul, SEEK_CUR);
			}
		    }
		} while (FirstLine.entry_type == 3);

		numlines = FirstLine.numlines;

		for (uNdx = 0; uNdx < numlines; uNdx++) {
		    switch (FirstLine.entry_type) {
		    case LINEREC_SRC_LINES:
			read(fh, &LineEntry, sizeof(LineEntry));
			/* Changed by Kim Rasmussen 26/06 1996 to ignore linenumber 0 */
			/* if (LineEntry.ulOffset+ssmod32.csOff<=ulOffset && LineEntry.ulOffset+ssmod32.csOff>=NearestLine) {} */
			if (LineEntry.LineNum &&
			    LineEntry.ulOffset + ssmod32.csOff >= NearestLine &&
			    LineEntry.ulOffset + ssmod32.csOff <= ulOffset)
			{
			    // Found better match
			    NearestLine = LineEntry.ulOffset;
			    NearestFile = LineEntry.FileNum;
			    sprintf(szNearestLine, "#%hu", LineEntry.LineNum);
			}
			break;

		    case LINEREC_LIST_LINES:
			lseek(fh, sizeof(struct linlist_rec), SEEK_CUR);
			break;

		    case LINEREC_SRCLIST_LINES:
			lseek(fh, sizeof(struct linsourcelist_rec), SEEK_CUR);
			break;

		    case LINEREC_FILENAMES:
			lseek(fh, sizeof(struct filenam_rec), SEEK_CUR);
			break;

		    case LINEREC_PATHINFO:
			lseek(fh, sizeof(struct pathtab_rec), SEEK_CUR);
			break;
		    } /* switch FirstLine.entry_type */
		} /* for */

		if (NearestFile != 0) {
		    // Have filename index - find name
		    // lseek back to filenames entry
		    lseek(fh, ulFileOffset, SEEK_SET);
		    read(fh, &FileInfo, sizeof(FileInfo));
		    namelen = 0;
		    for (uNdx = 1; uNdx <= FileInfo.file_count; uNdx++) {
			namelen = 0;		// in case read error
			read(fh, &namelen, 1);
			read(fh, szFuncName, namelen);
			if (uNdx == NearestFile)
			    break;	// Got it
		    }
		    szFuncName[namelen] = '\0';
		    psz = strrchr(szFuncName, '\\');
		    if (psz == NULL)
			psz = szFuncName;
		    else
			psz++;
		    strcpy(szNearestFile, psz);	// Record file name
		}
		else {
		    *szNearestFile = 0;
		}
		break; // SSTSRCLINES32

	    } /* switch sst */
	} /* for same module */
    } /* for uDirNdx < numdir */

    free(pDirTab32);
    return NO_ERROR;

} // Read32PmDebug

//== FormatVarValue() Format variable value, return string ==

static BYTE *FormatVarValue(PVOID pVar, BYTE type)
{
    // static BYTE szBuffer[128];	// 11 Oct 07 SHL
    APIRET rc;

    if (type == 0)
	sprintf(szBuffer, "%hd", *(signed char *)pVar);
    else if (type == 1)
	sprintf(szBuffer, "%hd", *(signed short *)pVar);
    else if (type == 2)
	sprintf(szBuffer, "%ld", *(signed long *)pVar);
    else if (type == 4)
	sprintf(szBuffer, "%hu", *(BYTE *)pVar);
    else if (type == 5)
	sprintf(szBuffer, "%hu", *(USHORT *)pVar);
    else if (type == 6)
	sprintf(szBuffer, "%lu", *(ULONG *)pVar);
    else if (type == 8)
	sprintf(szBuffer, "%f", *(float *)pVar);
    else if (type == 9)
	sprintf(szBuffer, "%f", *(double *)pVar);
    else if (type == 10)
	sprintf(szBuffer, "%f", *(long double *)pVar);
    else if (type == 16)
	sprintf(szBuffer, "%s", *(char *)pVar ? "TRUE" : "FALSE");
    else if (type == 17)
	sprintf(szBuffer, "%s", *(short *)pVar ? "TRUE" : "FALSE");
    else if (type == 18)
	sprintf(szBuffer, "%s", *(long *)pVar ? "TRUE" : "FALSE");
    else if (type == 20)
	sprintf(szBuffer, "%c", *(char *)pVar);
    else if (type == 21)
	sprintf(szBuffer, "%lc", *(short *)pVar);
    else if (type == 22)
	sprintf(szBuffer, "%lc", *(long *)pVar);
    else if (type == 23)
	sprintf(szBuffer, "void");
    else if (type >= 32) {
	// ULONG ulAttr;		// 10 Oct 07 SHL
	// ULONG ulSize = 1;		// 10 Oct 07 SHL
	ulSize = 1;

	rc = DosQueryMem((PVOID)*(ULONG *)pVar, &ulSize, &ulAttr);
	if (rc != NO_ERROR)
	    sprintf(szBuffer, "0x%p invalid", *(ULONG *)pVar);
	else {
	    sprintf(szBuffer, "0x%p", *(ULONG *)pVar);
	    if (ulAttr & PAG_FREE)
		strcat(szBuffer, " unallocated memory");
	    else {
		if (~ulAttr & PAG_COMMIT)
		    strcat(szBuffer, " uncommited");
		if (~ulAttr & PAG_WRITE)
		    strcat(szBuffer, " unwritable");
		if (~ulAttr & PAG_READ)
		    strcat(szBuffer, " unreadable");
	    }
	}
    }
    else {
      strcpy(szBuffer, "Unknown");
    }

    return szBuffer;

} // FormatVarValue

/**
 * Search saved user type definitions and print values if matched
 * @return TRUE if matched else FALSE
 */

static BOOL search_userdefs(ULONG stackofs, USHORT var_no)
{
    USHORT pos;

    for (pos = 0; pos < userdef_count && userdefs[pos].idx != autovars[var_no].type_idx; pos++)
	; // do nothing

    if (pos < userdef_count) {
	// Found it
	if (userdefs[pos].type_index >= 0x80 && userdefs[pos].type_index <= 0xDA)
	{
	    fprintf(hTrap, "%- 6d %- 20.20s %- 33.33s %s\n",
		    autovars[var_no].stack_offset,
		    autovars[var_no].name,
		    userdefs[pos].name,
		    FormatVarValue((PVOID)(stackofs + autovars[var_no].stack_offset),
				   userdefs[pos].type_index - 0x80));
	    return TRUE;
	}
	/* If the result isn't a simple type, let's act as we didn't find it */
    } // if found

    return FALSE;
} // search_userdefs

/**
 * Search saved pointer definitions and print values if matched
 * @return TRUE if matched else FALSE
 */

static BOOL search_pointers(ULONG stackofs, USHORT var_no)
{
    USHORT pos;
    USHORT upos;
    static BYTE str[35];

    for (pos = 0; pos < pointer_count && pointers[pos].idx != autovars[var_no].type_idx; pos++)
	; // do nothing

    if (pos < pointer_count) {
	// Found it
	if (pointers[pos].type_index >= 0x80 && pointers[pos].type_index <= 0xDA)
	{
	    strcpy(str, type_name[pointers[pos].type_index - 0x80]);
	    strcat(str, " *");
	    fprintf(hTrap, "%- 6d %- 20.20s %- 33.33s %s\n",
		    autovars[var_no].stack_offset,
		    autovars[var_no].name,
		    str,
		    FormatVarValue((PVOID)(stackofs + autovars[var_no].stack_offset), 32));
	    return TRUE;
	}
	else {
	    /* If the result isn't a simple type, look for it in the other lists */
	    for (upos = 0; upos < userdef_count && userdefs[upos].idx != pointers[pos].type_index; upos++)
		; // do nothing

	    if (upos < userdef_count) {
		strcpy(str, userdefs[upos].name);
		strcat(str, " *");
		fprintf(hTrap, "%- 6d %- 20.20s %- 33.33s %s\n",
			autovars[var_no].stack_offset,
			autovars[var_no].name,
			str,
			FormatVarValue((PVOID)(stackofs + autovars[var_no].stack_offset), 32));
		return TRUE;
	    }
	    else {
		/* If it isn't a userdef, for now give up and just print as much as we know */
		sprintf(str, "Pointer to type 0x%X", pointers[pos].type_index);

		fprintf(hTrap, "%- 6d %- 20.20s %- 33.33s %s\n",
			autovars[var_no].stack_offset,
			autovars[var_no].name,
			str,
			FormatVarValue((PVOID)(stackofs + autovars[var_no].stack_offset), 32));

		return TRUE;
	    }
	} // if not simple
    } // if found

    return FALSE;
} // search_pointers

/**
 * Print local variable values from stored data
 */

static VOID PrintLocalVariables(ULONG ulStackOffset)
{
    USHORT n;
    BOOL AutoVarsFound = FALSE;

    if (ulSymOffset == ulNearestPubOffset) {
	for (n = 0; n < autovar_count; n++) {
	    if (AutoVarsFound == FALSE) {
		AutoVarsFound = TRUE;
		fprintf(hTrap, "List of auto variables at EBP %p in %s:\n", ulStackOffset, szSymFuncName);
		fputs("Offset Name                 Type                              Value            \n", hTrap);
		fputs("ÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ\n", hTrap);
	    }

	    /* If it's one of the simple types */
	    if (autovars[n].type_idx >= 0x80 && autovars[n].type_idx <= 0xDA)
	    {
		fprintf(hTrap, "%- 6d %- 20.20s %- 33.33s %s\n",
			autovars[n].stack_offset,
			autovars[n].name,
			type_name[autovars[n].type_idx - 0x80],
		FormatVarValue((PVOID)(ulStackOffset + autovars[n].stack_offset),
			  autovars[n].type_idx - 0x80));
	    }
	    else {
		/* Complex type, check if we know what it is */
		if (!search_userdefs(ulStackOffset, n)) {
		    if (!search_pointers(ulStackOffset, n)) {
			fprintf(hTrap, "%- 6d %-20.20s 0x%X\n",
				autovars[n].stack_offset,
				autovars[n].name,
				autovars[n].type_idx);
		    }
		}
	    }
	}
#if 0 // fixme to be gone?
	if (AutoVarsFound == FALSE)
	    fprintf(hTrap, "  No auto variables found in %s.\n", szFuncName);
#endif
	if (AutoVarsFound)
	    fputc('\n', hTrap);
    }
} // PrintLocalVariables

// The end
